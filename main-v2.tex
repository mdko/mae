\documentclass[aspectratio=169]{beamer}
% \documentclass[aspectratio=169,handout]{beamer}

% Trying to use notes on separate page
% \documentclass[aspectratio=169,notes]{beamer}       % print frame + notes
% \documentclass[notes=only]{beamer}   % only notes
% \documentclass{beamer}              % only frames
%\usepackage{pgfpages}
%\setbeameroption{show notes}
%\setbeameroption{show notes on second screen=right}
%

%\setbeamercovered{transparent}

\usetheme[titleformat=regular%
,numbering=fraction% use slide numbers
]{metropolis}
\metroset{%
  progressbar=foot,%
  %background=dark,
  block=fill
}
\only<handout>{\metroset{sectionpage=none}}
\only<handout>{\usecolortheme{dove}}
\usepackage{appendixnumberbeamer} % separate appendix
\usepackage[citestyle=authortitle,sorting=none]{biblatex}
\setbeamerfont{footnote}{size=\tiny}
\addbibresource{mae.bib}

\input{macros}

\only<handout>{
  \pgfpagesuselayout{4 on 1}[letterpaper,border shrink=5mm,landscape]
}

\newtoggle{notes}
%\only<beamer>{\toggletrue{notes}}

% add notes:
\iftoggle{notes}{
  \makeatletter
  \def\beamer@framenotesbegin{% at beginning of slide
    %\gdef\beamer@noteitems{}%
    %\gdef\beamer@notes{}%
    \usebeamercolor[fg]{normal text}
  }
  \makeatother
  \setbeamertemplate{note page}[plain]
  \setbeamerfont{note page}{size=\footnotesize}
  \setbeameroption{show notes on second screen=right}
}{}

%\newtoggle{labdemo}
%\toggletrue{labdemo}
\newtoggle{TODO}
\toggletrue{TODO}

\title[Major Area Exam]{Memory Safety in Systems Languages} %Techniques for
%\subtitle{Tradeoffs in Efficiency and Completeness}
%\subtitle{A Balancing Act}
\subtitle{Major Area Exam}
\date{June 11, 2018}
\author{Michael Christensen}
\institute[UCSB]{
  \normalsize
  {\large \bfseries Committee:}\\
  Ben Hardekopf (\,$\vcenter{\hbox{\includegraphics[height=1em]{chair/file.eps}}}$) \quad
  Tim Sherwood \quad
  Rich Wolski
}
\titlegraphic{\hfill\includegraphics[width=2.25cm]{ucsbseal_cmyk.pdf}}

\begin{document}
\maketitle

\metroset{numbering=none}
\begin{frame}<beamer>[noframenumbering]
  \frametitle{Outline}
  \tableofcontents
\end{frame}
\metroset{numbering=fraction}

\section{Motivation}
\begin{frame}{What is a System?}
Infrastructure software upon which applications are built
\\
\vspace{0.2in}
\pause

Operating Systems \note{process abstraction, named resource management} % lowest level of abstraction
   \begin{itemize}
       \item Process abstraction
       \item Multiplex physical hardware resources
       \item Partition and abstract \textbf{memory}
   \end{itemize}

\vspace{0.2in}
\pause
Embedded Systems, \pause Compilers, \pause Garbage Collectors, \pause Device Drivers, \pause File Systems
\end{frame}

\note[itemize]{
  \item example: compilers, garbage collectors, file systems, drivers, etc.
  \item need to be able to do this
  \item isolation third item for os
  \item files: hide peculiarites of disks/I/O decives, abstract model of device-indepdent files
  \item address space: virtual memory + protection
  \item process: running program container (registers, files, alarms, address space, etc.)
  \item they're all stateful, imperative things
}

\begin{frame}{Systems Languages}
\begin{itemize}[<+->]
    \item Past systems languages: \tiny{ALGOL, PL/I, Fortran, BCPL/B, C, Mesa/Cedar, Pascal/Modula-2/Oberon, C++, ...}
    \item C: the de-facto standard
        \begin{itemize}
            \item Data structure representation control \note{how it looks}
            \item Memory management control \note{where it is, how long it lives}
            \item Complete mutability via pointers \note{with systems without protected address space, can literally write anything; embedded have memory-mapped I/O}
            \item Performant
            \item Legacy \note{alas: have to deal with it}
        \end{itemize}
    \item C: the unsafe standard
        \begin{itemize}
            \item Unchecked array operations $\Rightarrow$ buffer overflows
            \item Pointers $\equiv$ arrays $\Rightarrow$ hazardous pointer arithmetic
            \item Unsafe casts $\Rightarrow$ read/write arbitrary addresses, untyped
            \item Aliasing $\Rightarrow$ dangling pointers, double frees, null dereferences
            \item Undefined behavior $\Rightarrow$ \todo{insert nuke}
        \end{itemize}
\end{itemize}
\end{frame}

\note[itemize]{
\item possibly add OS lang was used for, date
\item ALGOL: formally defined syntax (OS: Burroughs, VME, Cambridge CAP)
\item PL/I: (OS: Multics)
\item Mesa, Cedar: rich exceptions, GC
\item Pascal (1971), Modula-2 (1982), Oberon (1988)
\item -- structured programming
\item -- records
\item -- pointers,
\item -- dynamic allocation,
\item -- information hiding,
\item -- objects
% see mae3.org, mae4.org
}

\begin{frame}{Memory Safety}
\begin{itemize}[<+->]
    %\item Memory safety error: ``Any dereference of a pointer or subscripted array reference which reads or writes storage outside of the referent'' \footcite{austin_efficient_1994}
    \item Memory safety error: Dereferencing a pointer which reads or writes storage outside of the referent
        \begin{itemize}
            \item Spatial: outside referent's \alert{address bounds}
            \item Temporal: outside referent's \alert{lifetime}
        \end{itemize}
        % TODO add graphic showing what I mean by referent
    \item Ideal technique is
        \begin{itemize}
            \item Efficient and expressive % (hallmarks of C)
            \item Purely static % (no runtime overhead, we will not have if we want computer help)
            % note: checking buffer overflows is generally undecidable
            \item Precise % (not overly conservative)
            \item Automatic % (legacy code $\Rightarrow$ no source or memory layout change)
        \end{itemize}
%    \item Non-goals: secrecy, security, concurrency, type safety % but are natural consequences of safety
    \item Memory errors become \alert{type errors}, management happens at \alert{compile-time}
\end{itemize}
\end{frame}

\note[itemize]{
\item some of those goals from nagakatte 201*
\item undecidability of checking certain dynamic errors
\item hard to verify/prove invariants about b/c
\item -- casts + pointers make c essentially untyped (rondon: type system is only to help know size of bytes to read/write)
\item -- aliasing
\item make bad hard, useful easy
}

\AtBeginSection[]
{
  \metroset{numbering=none}
  \begin{frame}<beamer>[noframenumbering]
    \frametitle{Outline}
    \tableofcontents[currentsection]
  \end{frame}
  \metroset{numbering=fraction}
}

\AtBeginSubsection[]
{
  \metroset{numbering=none}
  \begin{frame}<beamer>[noframenumbering] 
    \frametitle{Outline}   
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
  \metroset{numbering=fraction}
}

\only<handout>{
  \addtocounter{framenumber}{1}
}

\section{Spatial Safety}

\begin{frame}[fragile]{Spatial Safety}
\begin{columns}[T]
\begin{column}{0.48\textwidth}
Always access within object's \alert{bounds}
\\
\vspace{0.2in}
\onslide<6->{
Some approaches:
\begin{itemize}
      \item Fat Pointers and Shadow Structures
      \item Referent Objects
      \item Dependent Types
%      \item Hardware
  \end{itemize}
}
\end{column}
\pause
\begin{column}{0.50\textwidth}
    \vspace{-0.2in}
\begin{lstlisting}[
    language=C,mathescape,basicstyle={\small\ttfamily}]
struct { int *arr; int i; } s;
s.arr = calloc(3, sizeof(int));
\end{lstlisting}

    \pause

    \begin{tikzpicture}
      \node[draw, fill=black!10!white, minimum width=12mm, minimum height=5mm, label=left:0x18] (n0) {0x40};
      \node[draw, fill=black!10!white, minimum width=12mm, minimum height=5mm, below=-\pgflinewidth of n0, label=left:0x1c] (n1) {.};
      \node[draw, minimum width=12mm, minimum height=5mm, below=-\pgflinewidth of n1,, label=left:0x20] (n2) {.};
      \node[draw, minimum width=12mm, minimum height=5mm, below=-\pgflinewidth of n2,, label=left:0x24] (n3) {.};
      \node[minimum width=12mm, minimum height=5mm, below=-\pgflinewidth of n3,,] (n4) {...};
      \node[draw, minimum width=12mm, minimum height=5mm, below=-\pgflinewidth of n4,, label=left:0x3c] (n5) {.};
      \node[draw, fill=black!30!white, minimum width=12mm, minimum height=5mm, below=-\pgflinewidth of n5,, label=left:0x40] (n6) {0};
      \node[draw, fill=black!30!white, minimum width=12mm, minimum height=5mm, below=-\pgflinewidth of n6,, label=left:0x44] (n7) {0};
      \node[draw, fill=black!30!white, minimum width=12mm, minimum height=5mm, below=-\pgflinewidth of n7,, label=left:0x48] (n8) {0};
      \node[draw, minimum width=12mm, minimum height=5mm, below=-\pgflinewidth of n8,, label=left:0x50] (n9) {.};
      \node[left = 1.5cm of n0] () {\textbf{s.arr}};
      \node[left = 1.5cm of n1] () {\textbf{s.i}};
      \onslide<3> \draw [->,black] (n0.east) to [out=315,in=45] (n6.east);
      \onslide<4> \draw[->,black] (n0.east) to [out=315,in=45] (n5.east);
      \onslide<5,6-> \draw[->,black] (n0.east) to [out=315,in=45] (n9.east);
    \end{tikzpicture}
\end{column}
\end{columns}

\end{frame}

\begin{frame}[fragile]{Spatial Safety Example}
\begin{columns}[T]
\begin{column}{0.52\textwidth}
\begin{lstlisting}[
    language=C,numbers=left,mathescape,basicstyle={\small\ttfamily},
    moredelim={**[is][{\btHL<1>}]{@1}{@}},
    moredelim={**[is][{\btHL<2>}]{@2}{@}},
    moredelim={**[is][{\btHL<3>}]{@3}{@}},
    moredelim={**[is][{\btHL<4>}]{@4}{@}},
    moredelim={**[is][{\btHL<5>}]{@5}{@}},
    moredelim={**[is][{\btHL<6>}]{@6}{@}},
    moredelim={**[is][{\btHL<7>}]{@7}{@}},
]
@2int find_token(int *data,@
@2               int *end,@
@2               int token)@
{
    @3int *p = data;@
    @4while (p < end) {@
    @5    if (*p == token) break;@
    @6    p++;@
    }
    @7return (*p == token);@
}
\end{lstlisting}
\end{column} 
\begin{column}{0.44\textwidth}

\onslide<8->
\footnotesize{
Potential pointer dereference problems:
  \begin{itemize}[<+->]
      \item Null
      \item Uninitialized
      \item Out-of-bounds \note{related: data might not be an array, unrelated}
      \item Manufactured \note{not shown here exactly}
  \end{itemize}
}
\end{column}
\end{columns}

\end{frame}

\subsection{Fat Pointers and Shadow Structures}

\begin{frame}[fragile]{Fat Pointers}
  \footnotesize
%Fat Pointers
\vspace{-0.1in}
\pause
\begin{columns}[T]
\begin{column}{0.64\textwidth}
\begin{itemize}[<+->]
 \item Added base and bound addresses \note{multiword, and other information}
 \item Instrument all pointers and functions
 \item Insert runtime checks \alert{before dereferences}, not arithmetic \note{as opposed to during arith, let arithmetic happen as usual}
 \item Advantages:
     \begin{itemize}
        \item Quickly find and retrieve metadata \note{no costly db lookup}
        \item Complete spatial safety \note{only way to enforce complete spatial safety is tracking ptr bnds}
        \item No sub-object overflows \note{will explain next section}
     \end{itemize}
 \item Disadvantages:
     \begin{itemize}
        \item Breaks binary compatibility \note{calling convention of external/uninstrumented libraries, storing pointer in register, casting ptr to int and back}
        \item Metadata propagation on pointer assignment
        \item Code bloat, memory usage, runtime overhead \note{up to 200, because of added checks, bigger ptrs}
        \item Unsafe casts can overwrite metadata
     \end{itemize}
\end{itemize}
\end{column}

\begin{column}{0.47\textwidth}

   \pause

\begin{lstlisting}[
    language=C,mathescape,basicstyle={\scriptsize\ttfamily}]
struct fptr { int *curr;
     int *base; int *bound; };
struct { struct fptr arr; int i; } s;
s.arr.curr = calloc(3, sizeof(int));
\end{lstlisting}

    \pause

    \begin{tikzpicture}
      \node[draw, fill=black!10!white, minimum width=12mm, minimum height=5mm, label=left:0x18] (n0) {0x40};
      \node[draw, fill=black!10!white, minimum width=12mm, minimum height=5mm, below=-\pgflinewidth of n0, label=left:0x1c] (n1) {0x40};
      \node[draw, fill=black!10!white, minimum width=12mm, minimum height=5mm, below=-\pgflinewidth of n1,, label=left:0x20] (n2) {0x4c};
      \node[draw, fill=black!10!white, minimum width=12mm, minimum height=5mm, below=-\pgflinewidth of n2,, label=left:0x24] (n3) {.};
      \node[minimum width=12mm, minimum height=5mm, below=-\pgflinewidth of n3,,] (n4) {...};
      \node[draw, minimum width=12mm, minimum height=5mm, below=-\pgflinewidth of n4,, label=left:0x3c] (n5) {.};
      \node[draw, fill=black!30!white, minimum width=12mm, minimum height=5mm, below=-\pgflinewidth of n5,, label=left:0x40] (n6) {0};
      \node[draw, fill=black!30!white, minimum width=12mm, minimum height=5mm, below=-\pgflinewidth of n6,, label=left:0x44] (n7) {0};
      \node[draw, fill=black!30!white, minimum width=12mm, minimum height=5mm, below=-\pgflinewidth of n7,, label=left:0x48] (n8) {0};
      \node[draw, minimum width=12mm, minimum height=5mm, below=-\pgflinewidth of n8,, label=left:0x4c] (n9) {.};
      \node[left = 1.0cm of n0] () {\textbf{s.arr.curr}};
      \node[left = 1.0cm of n1] () {\textbf{s.arr.base}};
      \node[left = 1.0cm of n2] () {\textbf{s.arr.bounds}};
      \node[left = 1.0cm of n3] () {\textbf{s.i}};
      \draw [->,black] (n0.east) to [out=315,in=45] (n6.east);
      \onslide<17-> \draw[->,black] (n1.east) to [out=315,in=45] (n6.east);
      \onslide<18-> \draw[->,black] (n2.east) to [out=315,in=45] (n9.east);
    \end{tikzpicture}
\end{column}
\end{columns}

\end{frame}
% write wrappers to remove inline metadata before calling outside function
% have to instrument malloc...

\note[itemize]{
\item Source-code annotations, for some
\item Impractical for large code bases
\item Two distinct pointers can point to same object and have diff base/bounds associated with them
\item Overcomes sub-object overflows b/c can be detected b/c uniqueness of each ptr
}

\begin{frame}{Fat Pointer Approaches}
SafeC \footcite{austin_efficient_1994}:
\begin{itemize}
  \item \alert{Safe} pointers have value, base, and size
  \item Complete spatial safety, if \alert{transparent} storage management and no safe pointer attribute \alert{manipulation} \note{no domain-specific allocator at user-level}
  \item 275\% space overhead, 2-6x runtime overhead, 0.35-3x code size overhead \note{no register allocated safe ptrs, compiler optimizations fail with additional checks}
  \item Some static optimization based on still-valid previous checks
\end{itemize}

\pause 
%TODO {maybe "Low-cost concurrency checking of pointers" Patil 1997}
%TODO {maybe "Bounds-checking entire programs without recompiling" Nethercote 2004}

Cyclone \footcite{jim_cyclone:_2002}: \note{offshoot of TAL/popcorn}
\begin{itemize}
    \item Annotations for non-array vs array pointers (can specify size) % (never-null, fat, unitialized warning via control-flow analysis) % TODO look up again, split this
    \item Tagged unions and automatic tag injection \note{(e.g. instead of var-args, know exactly what's stored in thing callee passed $\texttt{printf}$)}
    %\item Can specify number of elements pointer points to \note{deputy is more general}
    %\item Arrays and strings converted automatically to fat
    %\item Statically validate and remove non-array fat pointers
    %\item 40\% runtime overhead
    %\item Uses regions + automatic memory management for temporal safety (free is a no-op) (see nice example)
    %\item never null don't need checks, use @; push back null checks from uses to their sources
    %\item Restrict arithmetic on regular pointers
    %\item parametric polymorphism, subtyping, static analysis to check for safety, adding run-time checks
\end{itemize}
\vspace{0.1in}

\end{frame}

\begin{frame}{Fat Pointer Approaches}
 CCured \footcite{necula_ccured:_2002}
\begin{itemize}
    \item Separate pointers on usage (SAFE, SEQ, WILD) \note{safe: used w/o casts or ptr arith, either null or valid; seq: arith but no casts; wild: everything else}
    \item Whole-program inference to find as many SAFE then SEQ pointers as possible \note{via constraint collection}
    \item Reduce WILD pointers \footcite{necula_ccured:_2005} using physical subtyping \footcite{siff_coping_1999} for upcasts
    \item Special pointer RTTI carrying runtime type for downcasts \note{i.e. void* to anything, rttiOf mapping a type to node in physical subtyping hierarchy, store type info with ptr not object so they can point to inside of allocation unit}

    \note{wild: all regular ptrs can be treated as WILD (arbitrary casts, expensive dynamic checks)}
    \note{WILD/DYNAMIC: ptr type does not carry wit it the type of values pointed to}
    \note{seq: like fat pointers}
    \note{safe: if not null, guaranteed to point to memory are containing compatibly-typed object}
    \note{Relies on a garbage collector}
    \note{3\%-87\% runtime overhead increase}
\end{itemize}

% possible 2005: fig 5-6 

\pause

Fail-Safe C \footcite{oiwa_implementation_2009}:
\begin{itemize}
    \item Combines fat pointers w/ fat integers and virtual structure offsets
\end{itemize}

\vspace{0.2in}
\end{frame}

% use CCured syntax (2002, 2005 has a good translation definition)
\begin{frame}[fragile]{Fat Pointers Preventing Spatial Errors}
    \begin{columns}[T]
      \begin{column}{0.44\textwidth}
\begin{lstlisting}[language=C,numbers=left,mathescape,basicstyle={\scriptsize\ttfamily}]
int find_token(int *data,
               int *end,
               int token)
{
    int *p = data;
    while (p < end) {



        if (*p == token) break;


        p++;
    }

    return (*p == token);
}
\end{lstlisting}
\end{column}

\pause

\begin{column}{0.56\textwidth}

\begin{lstlisting}[language=C,numbers=left,mathescape,basicstyle={\scriptsize\ttfamily},
    moredelim={**[is][\btHL<3>]{@3}{@}},
    moredelim={**[is][{\btHL<4>}]{@4}{@}},
    moredelim={**[is][{\btHL<5>}]{@5}{@}},
    moredelim={**[is][{\btHL<6>}]{@6}{@}},
    moredelim={**[is][{\btHL<7>}]{@7}{@}},
    moredelim={**[is][{\btHL<8>}]{@8}{@}}
]
int find_token(int *@3SEQ@ data,
               int *@4SAFE@ end,
               int token)
{
    int *@3SEQ@ p = data;
    @5while (p.value < end)@ {
        @6assert(p.base != 0 &&@
        @6         0 <= p.value &&@
        @6         p.value < p.bound);@
        @6if (*p.value == token) break;@
        @7p.value = p.value + (1 * sizeof(int));@
        @7p.base  = p.base;@   // optimized out
        @7p.bound = p.bound;@  // "           "
    }
    @6...(repeat lines 7-9)...@
    @5return (*p.value == token);@
}
\end{lstlisting}
\end{column}

\end{columns}
\end{frame}

\begin{frame}{Pointer-Based -- Shadow Structures}
MSCC \footcite{xu_efficient_2004}
\pause
\begin{itemize}
    \item \emph{Split} metadata from pointer, preserving layout \note{some libraries access based off of struct offset, or assume size of integer and ptr is same}
    \item Every value has linked shadow structure mirroring entire data structure
    \item Transform every function call to take additional metadata parameters
    \item Wrappers for external functions; cannot detect memory errors \note{Out-of-sync metadata after external library code}
  % \item Generate metadata for library routines returning newly allocated object
  % \item Does not handle arbitrary casts % TODO not sure exactly how to explain this succinctly
  % \item Optimized encoding loses ability to detect sub-object overflows % no need to mention since we haven't talked about those flows yet
\end{itemize}
\end{frame}

% MSCC style
\begin{frame}[fragile]{Shadow Structures Example}
\begin{columns}
\begin{column}{0.42\textwidth}
\begin{lstlisting}[language=C,numbers=left,mathescape,basicstyle={\scriptsize\ttfamily}]




int find_token(
  int *data,
  int *end,
  int token)
{
    int *p = data;

    while (p < end) {

        if (*p == token) break;
        p++;
    }

    return (*p == token);
}
\end{lstlisting}
\end{column}

\pause

\begin{column}{0.56\textwidth}

\begin{lstlisting}[language=C,numbers=left,mathescape,basicstyle={\scriptsize\ttfamily},
    moredelim={**[is][{\btHL<3>}]{@3}{@}},
    moredelim={**[is][{\btHL<4>}]{@4}{@}},
    moredelim={**[is][{\btHL<5>}]{@5}{@}},
    moredelim={**[is][{\btHL<6>}]{@6}{@}},
]
@3struct ptr_info {@
@3    void *base;@
@3    unsigned long bound;@
@3};@
int find_token(
  int *data, @4ptr_info *data_info,@
  int *end,  @4ptr_info *end_info,@
  int token)
{
    int *p = data;
    @5ptr_info  p_info = *data_info;@
    while (p < end) {
        @6CHECK_SPATIAL(p, sizeof(*p), p_info);@
        if (*p == token) break;
        p++;
    }
    @6CHECK_SPATIAL(p, sizeof(*p), p_info);@
    return (*p == token);
}
\end{lstlisting}
    \end{column}
  \end{columns}
\end{frame}

% TODO question: where is table stored (heap or stack?)
% TODO insert table-of-contents

\subsection{Referent Objects}

\begin{frame}[fragile]{Referent Objects}
    Objects \footcite{jones_backwards-compatible_1997}\footcite{ruwase_practical_2004}
\footnotesize
\begin{columns}[T]
\begin{column}{0.45\textwidth}
\begin{itemize}[<+->]
    \item Metadata about \alert{objects}, not pointers
    \item Global database relates every allocated address to corresponding object metadata \note{updating on alloc, dealloc, on function entry/exit for stack-based objects, program startup for global object}
    \item Every pointer to same object shares same metadata
    \item Bounds check on \alert{pointer arithmetic} \note{and array indexing} to ensure validity of derived pointers \note{i.e. point to same object}
    \item 2-12x overhead
    %\item do not check pointer derferences
\end{itemize}
\end{column}

\pause

\begin{column}{0.45\textwidth}
Advantages:
\begin{itemize}
  \item Compatible with uninstrumented code \note{no memory layout change; if pointer updated by untrusted module, metadata out-of-sync}
\end{itemize}
\pause
Disadvantages:
\begin{itemize}
  \item Special mechanisms to handle legal OOB pointers \note{since going 1 past array undereferenced is legal C}
  \item Splay-tree object lookup overhead
  \item Incomplete spatial safety: \alert{sub-object overflows} \note{type casts, mem corruption in objects, C allows ptr arith in struct fields}
\end{itemize}
\end{column}
\end{columns}

\vspace{0.1in}

\end{frame}

\note[itemize]{
\item jones and kelly: pad objects w/ extra byte
\item check ptr arith and use, b/c result cannot refer to diff object from one from which it is originally derived
\item object for which the ptr is valid is only determined by checking ptr itself, looking it up in object table
\item Incomplete because cannot pad parameters, would change layout
\item cred: more generic solution
}

\begin{frame}[fragile]{The Sub-Object Problem}
\begin{lstlisting}[
    language=C,numbers=left,mathescape,basicstyle={\normalsize\ttfamily},
    moredelim={**[is][{\btHL<2>}]{@2}{@}},
    moredelim={**[is][{\btHL<3>}]{@3}{@}},
    moredelim={**[is][{\btHL<4>}]{@4}{@}},
    moredelim={**[is][{\btHL<5>}]{@5}{@}}
]
@2struct node {char str[3]; void (*func)(); };@
@3struct node *n = (struct node *) malloc(sizeof(node));@
@4char *s = n.str;@
@5strcpy(s, "bad!");@
\end{lstlisting}


\onslide<6->
    \begin{itemize}
        \item $\texttt{n}$ and $\texttt{s}$ have the same address $\Rightarrow$ map to same object in global database
        \item $\texttt{strcpy}$ will see $\texttt{s}$'s size as that of $\texttt{n}$
    \end{itemize}

\end{frame}

\note[itemize]{
\item Because nested objects (e.g., an array of structures) are assigned base and bound addresses
\item that span the entire allocated region, it is impossible to detect sub-object overflows if an
\item out-of-bounds pointer to an inner object remains within bounds of the outer object.
}

% TODO possibly "Applied to linux kernel: Criswell Secure virtual arch 2007"

%\begin{frame}{Referent Objects Approaches}
%J\&K \footcite{jones_backwards_1997}
%    \begin{itemize}
%       %\item Maintain table of all known valid storage objects
%       %\item Map a ptr to a desciptor of the object into which it points
%       \item Pad objects w/ extra byte \todo{why}
%       %\item check ptr arith and use, b/c result cannot refer to diff object from one from which it is originally derived
%       %\item object for which the ptr is valid is only determined by checking ptr itself, looking it up in object table
%       \item Incomplete because cannot pad parameters \note{would change layout}
%       \item 11-12x overhead
%    \end{itemize}
%
%CRED \footcite{ruwase_practical_2004}
%    \begin{itemize}
%      \item More generic solution \todo{how}
%      \item 2x overhead
%    \end{itemize}
%\vspace{0.2in}
%\end{frame}

\begin{frame}[fragile]{Referent Objects Approaches}
SafeCode \footcite{dhurjati_backwards-compatible_2006}
    \begin{itemize}
        \item Use automatic pool allocation (APA) \footcite{lattner_automatic_2005} \note{builds on JK, APA: partitions memory based on static points-to analysis}
        \item Use separate, \alert{smaller} data structures to store bounds metadata for \alert{each partition}
        \item 1.2x overhead
    \end{itemize}

\pause

Baggy Bounds Checking (BBC) \footcite{akritidis_baggy_2009}
    \begin{itemize}
    %\item Trades memory for performance \note{fastest object bounds checker}
    \item Compact bounds representation and efficient way to look up object bounds
    \item Pad every object s.t. size is power of two, align base addresses to be multiple of their padded size
    \item Replace splay tree with small lookup table
    \item 0.6x overhead \note{on SPECINT 2000 benchmark}
    %\item partition memory into slots with slot_size bytes (table has entry per slot rather than per byte)
    \end{itemize}
\vspace{0.2in}
% TODO read this paper more: great succinct explanation of this approach (p 2)

%PariCheck \footcite{younan_paricheck_2010} \note{like BBC, faster/lower overhead}
\end{frame}

\begin{frame}[fragile]{Referent Objects Example}
\footnotesize
\begin{columns}[T]
\begin{column}{0.42\textwidth}
\begin{lstlisting}[language=C,numbers=left,mathescape,basicstyle={\scriptsize\ttfamily}]
int find_token(int *data,
               int *end,
               int token)
{
    int *p = data;
    while (p < end) {
        if (*p == token) break;




        p++;
    }
    return (*p == token);
}
\end{lstlisting}
\end{column}

\pause

\begin{column}{0.56\textwidth}
\begin{lstlisting}[
    language=C,numbers=left,mathescape,basicstyle={\scriptsize\ttfamily},
    moredelim={**[is][{\btHL<3>}]{@3}{@}},
    moredelim={**[is][{\btHL<4>}]{@4}{@}},
    moredelim={**[is][{\btHL<5>}]{@5}{@}},
    moredelim={**[is][{\btHL<6>}]{@6}{@}},
]
int find_token(int *data,
               int *end,
               int token)
{
    int *p = data;
    while (p < end) {
        if (*p == token) break;
        @3int *q = p + 1;@
        @4int size = 1 << TABLE[p>>4];@
        @5int base = p & ~(size - 1);@
        @6assert(q >= base && q - base < size);@
        p++;
    }
    return (*p == token);
}
\end{lstlisting}
%Lines 4-6 are equivalent to $\texttt{assert((p^q)>>TABLE[p>>SLOT_SIZE] == 0)}$.
\end{column}

\end{columns}
\end{frame}

% TODO add diagram of memory layout and how this ptr arith works!!!

% Mudflap: Eigler 2003
% Criswell: Secure Virt Arch 2007
% PariCheck: Younan: 2010


%\begin{frame}{Fat Pointers}
%\todo{put somewhere else}
%Cuckoo \footcite{west_cuckoo:_2005}
%      \begin{itemize}
%          \item Store array size in memory before array dimensions' first element
%          \item Name of an array is pointer to an \emph{array}, not first object
%          \item Type system for preventing assignment of automatic objects into longer-lifetime pointers
%          %\item Wrap dynamic memory allocation (type homogeneous pool-based) % will explain later
%          \item Forbid addition and subtraction expressions including pointer operands! % TODO what?! statically determining given pointer points to an array object is undecidable
%        % compile-time checks if array bounds are constants, otherwise run-time checks
%      \end{itemize}
%\end{frame}

\begin{frame}{Softbound}
\footnotesize
Softbound \footcite{nagarakatte_softbound:_2009}
    \begin{itemize}[<+->]
        \item Base and bound metadata for each pointer, stored in disjoint metadata space (via table lookups) \note{like pointer-based and object approaches, two-level trie data structure in disjoint metadata space}
        \item Total spatial safety of pointer-based approaches \note{eliminate sub-object problem}
        \item Source compatibility, separate compilation of object-based approaches
        \item Runtime bounds checks on each dereference
        \item Propagate metadata as extra arguments \note{to function calls, wrappers for commonly-used libraries, must transform every func decl/call-site, or shadow stack (nagarakatte thesis)}
        \item Arbitrary casts allowed \note{just check ptr involved in casts on derfernce w.r.t to its metadata, no way to overwrite metadata}
        \item 67\% overhead
%        \item Must protect every module for *complete* safety (untrusted module can modify ptr, table is out-of-sync)
%        \item Only store metadata in disjoint space for pointers in memory, perform metadata loads/stores only when loaded/stored value from/into memory loc is a ptr
%        \item Wrappers for commonly used libraries
    \end{itemize}
\end{frame}
% TODO lookup how 'lookup works'

% TODO update running example, or add in softbounds pictures! (or reserve for CETS)

%\begin{frame}{Hardware Approaches to Spatial Safety}<presentation:0>
%    \begin{itemize}
%       \item Hardbound: Devietti 2008
%       \item Intel MPX %: \verbatim{https://gcc.gnu.org/wiki/Intel%20MPX%20support%20in%20the%20GCC%20compiler}
%       \item Watchdog: Nagarakatte 2012
%       \item (Hybrid): WatchdogLite
%    \end{itemize}
%\end{frame}

%\begin{frame}{Other Spatial Approaches}<presentation:0>
%\begin{itemize}
% \item (Also: tripwire approaches, mostly for testing): TODO need to have reason why I'm skipping
% \item Hastings Purify 1992 (reveal during testing), object based, has temporal safety
% \item Nethercote Valgrind 2007 (reveal during testing)
% \item Qin SafeMem 2005
% \item Venkataramani Memtracker 2007
% \item Yong "Protecting C" 2003
% \item Serebryany AddressSanitizer 2012: object-based, has temporal safety
%\end{itemize}
%\end{frame}

% TODO describe why not mentioning ETC/LCLint/CSSV/Abcd are static analyzers, not built-in lang techniques

\subsection{Dependent Types}

\begin{frame}{Dependent Types}
    Dependent types are \emph{typed-valued functions} \footcite{pierce_advanced_2005}
    % type family of vectors
    % dependent product type
\pause
\begin{center}
   $\texttt{Vector : Nat}\rightarrow\texttt{Type}\rightarrow\texttt{Type}$
   \pause
   \\
   $\texttt{nil : Vector 0 a}$
   \\
   \pause
   $\texttt{cons : }\Pi\texttt{n:Nat.a}\rightarrow\texttt{Vector n a}\rightarrow\texttt{Vector (n+1) a}$
   \\
   \pause
   $\texttt{(cons 'a' (cons 'b' nil)) : Vector 2 Char}$
   \\
   \pause
   $\texttt{head :}\Pi\texttt{n:Nat.Vector a (n+1) -> a}$
   \\
   \pause
   $\texttt{head nil}$ \pause $\Rightarrow$ \textcolor{red}{Rejected!}
\end{center}
    \pause
    \begin{itemize}
        \item Based on type theory work by Martin-L{\"o}f \footcite{martin-lof_constructive_1984}
        \item Undecidability of type checking: arbitrary computation to check type equality
        \item Work on defining equality and restricting forms of index terms
    \end{itemize}
    \vspace{0.1in}
\end{frame}
\note[itemize]{
  \item Declares a family of types
  \item We say that Vect is indexed over Nat and parameterised by Type
}

\begin{frame}{Early Uses of Dependent Types}
Dependent ML \footcite{xi_eliminating_1998} and Cayenne \footcite{augustsson_cayennelanguage_1998}
\begin{itemize}
    \item Reduce static array bound checking to constraint satisfiability
    \item DML uses \emph{indexed types}: limit indices to linear integer and boolean expressions; compile-time decidable \note{decidable logic}
    \item Cayenne has \emph{no restrictions} on types: undecidability of arbitrary expression equivalence and thus type checking \note{haskell-like}
    %\item User provides types of recursive procedures and inductive datatypes
\end{itemize}
Xanadu \footcite{xi_imperative_2000}
\begin{itemize}
    \item Imperative environment \note{C-like}
    \item Restrict index expressions in types to integer constraint domain \note{like DML}
%    \item Defines what it means for a type to equal/coerce into another
%    \item Programmer must supply state type in order to type conditionals and loops \todo{remove?}
\end{itemize}
    \vspace{0.2in}
\end{frame}
\note[itemize] {
\item the goal here is just to show that FuncLangs did it first, but they aren't always practical b/c of undecidability, difficult to use
\item infuttered form, you get CoC
}

% \item Allows trusted cast mechanism to supress errors

\begin{frame}{Dependent Types in Imperative Languages}
    SafeDrive \footcite{zhou_safedrive:_2006} and Deputy \footcite{condit_dependent_2007}\footcite{anderson_static_2007}
%\vspace{-0.1in}
    \begin{itemize}[<+->]
        \item User-added annotations relating pointers to bounds
            \begin{itemize}
                \item \texttt{safe}, \texttt{sentinel}, \texttt{count(n)}, \texttt{bound(lo,hi)}
                \item Use constants/variables/field names in immediately enclosing scope \note{n, lo, hi are expressions}
            \end{itemize}
        %\item allow programmers to specify common c programming idioms involving ptr arith and union types
        %\item compiler checks safety of most pointer and union operations
        \item Three-phase pass over annotated C programs, emits C code
            \begin{enumerate}
                \item Automatic addition of bounds annotations for pointer types \note{fresh local var to hold bounds}
                \item Flow-insensitive type checking (insert run-time checks; helps decidability) \note {hybrid means SA for type determination, run-time checks when SA precision is too low}
                \item Flow-sensitive check optimization
            \end{enumerate}
        \item More C Support: mutable structures, dependent union tags \note{c idiom: tag indicates union field in use}, Safe TinyOS \footcite{cooprider_efficient_2007} %\footcite{hill_system_2000}, \footcite{gay_nesc_2003}, \footcite{cooprider_efficient_2007}
    \end{itemize}
    \vspace{0.2in}
\end{frame}

\note[itemize]{
% they're really *hybrid* approach: try your best, then offer runtime checks
% TODO maybe include this info (next few items)
  \item track info required to place run-time checks (asserts) in program
  \item  flow- path-insensitive, bolvious to aliasing, heap updates, data structures
  \item local type inference
  \item static verifier discharges checks at compile-time
% about annotations
  \item safe = ptr is null/pts to single element of base type
  \item sentintel = only for comparisons
  \item count(n) = null or point to an array of at least nelements of base type
  \item bounds(lo,hi) = null or point into mem region w/ low address lo, hi is first element beyond region end
  \item: invariant is that ptrs null, or within stated bounds
% dependent union tags
  \item c idiom: tag indicates union field in use
  \item Specify the condition for each union field to be usable
  \item \emph{$\text{union}_n\ \tau_1\ ...\ \tau_n\ e_1\ ...\ e_n$}
  \item $x:\text{struct }\{ tag:\text{int}\;\ u: \text{union}_2 \text{ int (ref int)} \ (\textit{tag} \geq 2)\ (\textit{tag} = 1) \}$
% generalized ptr
  \item Generalize array constructor to possibly-null bounded pointer
  \item C-style pointer arithmetic via $\oplus$ operator % TODO why use that special symbol?
  \item $x:\text{ptr int } x\ (x \oplus n)$ $\texttt{// n integer area starting at x}$
  \item $x:\text{ptr int } x\ e\ \ \ \ \ \ \ \ $ $\texttt{// from x to e}$
% TODO: are the assertions to make it safe (catch bad things), or an assertion something that is known to be true
}

% go through an example to get a feeling, then after explaining judgments, explain it again stepping through the judgments
\begin{frame}[fragile]{Deputy Example for Spatial Safety}
\begin{columns}[T]
\begin{column}{0.40\textwidth}
\begin{lstlisting}[language=C,numbers=left,mathescape,basicstyle={\scriptsize\ttfamily}]
int find_token(int *data,
               int *end,
               int token)
{


    int *p = data;
    while (p < end) {


        if (*p == token) break;

        p++;
    }


    return (*p == token);
}
\end{lstlisting}
\end{column}

%\scriptsize{$\colorbox{blue!30}{Code added during automatic dependency inference}$}

\pause

\begin{column}{0.58\textwidth}
\begin{lstlisting}[
    language=C,numbers=left,mathescape,basicstyle={\scriptsize\ttfamily},
    moredelim={**[is][{\btHL[onslide=<3->{fill=blue!50}]}]{@3}{@}},
    moredelim={**[is][{\btHL[onslide=<4->{fill=blue!50}]}]{@4}{@}},
    moredelim={**[is][{\btHL[onslide=<5->{fill=blue!50}]}]{@5}{@}},
    moredelim={**[is][{\btHL[onslide=<6->{fill=red!50}]}]{@6}{@}},
    moredelim={**[is][{\btHL[onslide=<7->{fill=red!50}]}]{@7}{@}},
    moredelim={**[is][{\btHL[onslide=<8->{fill=red!50}]}]{@8}{@}},
    moredelim={**[is][{\btHL[onslide=<9->{fill=red!50}]}]{@9}{@}},
]
int find_token(int * @3bound(cur, end)@ data,
               int * @4sentinel@ end,
               int token)
{
    @6assert(data != NULL);@
    @6assert(end != NULL);@
    int *p @5bound(cur, end)@ = data;
    while (p < end) {
        @7assert(p != NULL);@
        @7assert(p < end);@
        if (*p == token) break;
        @8assert(p <= p + 1 <= end);@
        p++;
    }
    @9assert(p != NULL);@
    @9assert(p < end);@
    return (*p == token);
}
\end{lstlisting}
\end{column}
\note[itemize]{
\item Let's assume that the code is fully annotated (automatic generation coming later)
\item No arithmetic/comparisons on null ptrs
\item 8 assert: legal to point past end
\item 9 illegal to access
}

\end{columns}
\end{frame}
% \note{All checks here would be eliminated}

% \note{here I need to exaplin what a grammer is for them}
\begin{frame}{Abstract Syntax, For Your Consideration}
\begin{gather*}
    x,y \in \text{Variables}
    \quad
    \text{op} \in \text{Binary ops}
    \quad
    n \in \text{Integers}
    \quad
    \text{comp} \in \text{Comparison Ops}
\end{gather*}

\vspace{0.2in}

\begin{columns}[T]
\begin{column}{0.45\textwidth}
\begin{alignat*}{2}
\textit{Ctors}\quad &C &&::= \text{int} \altm \text{ref} \altm \text{array}
\\
\textit{Types}\quad &\tau &&::= C \altm \tau_1 \ \tau_2 \altm \colorIt{blue}{n1}{\tau\ e}
%\\
%\text{Kinds}\quad & \kappa &&::= \text{type} \altm \text{type} \rightarrow \kappa \altm \tau \rightarrow \kappa
\\
\textit{L-exprs} \quad &l &&::= x \altm *e
\end{alignat*}
\end{column}

\pause

\begin{column}{0.45\textwidth}
\begin{alignat*}{2}
\textit{Exprs}\quad &e &&::= n \altm l \altm e_1 \text{ op } e_2
\\
\textit{Cmds}\quad &c &&::= \altm l := e \altm \colorIt{red}{n2}{\text{assert}(\gamma)} \altm c_1;c_2 \altm ...
\\
%\textit{Cmds}\quad &c &&::= \text{skip} \altm c_1;c_2 \altm l := e \altm \colorIt{red}{n2}{\text{assert}(\gamma)} \altm
%\\
%~ & ~ && \text{let } x : \tau = e \text { in } c \altm \text{let } x = \text{new } \tau(e) \text{ in } c
%\\
\colorIt{green}{n3}{\text{Preds}} \quad &\gamma &&::= e_1 \text{ comp } e_2 \altm \text{true} \altm \gamma_1 \wedge \gamma_2
\end{alignat*}
\end{column}
\end{columns}

\vspace{0.1in}
\end{frame}

%\scriptsize{$\colorbox{green!30}{Programmer-supplied annotation}$}

\note[itemize]{
\item kind of int is "type"
\item kind of ref is "type -> type"
\item loops, conditionals omitted for flow-insenstivei type system
\item Types restricted to only contain expressions using constatns, local variables, arbitrary arithmetic operators
\item Type environment is a predicate on the state of the program
}

% todo add some color, at least to one or two judgments for explanation
\begin{frame}{Typing Rules, For Your Consideration}
\note{local expression: expressions formed using constants, local variables, arbitrary arithmetic operators (no memory deferences}
\note{expressions in types are restricted to local expressions}

Local Expressions: $\Gamma \vdash_{L} e : \tau$
%Local Expressions: $\colorIt{red}{n1}{\Gamma } \colorIt{blue}{n2}{\vdash_{L} e} \colorIt{orange}{n3}{: \tau}$
\vspace{-0.1in}
\pause
\begin{center}
\begin{tabular}{cc}
\infer[(\textsc{local\ name})]
{\colorIt{red}{n1}{\Gamma } \colorIt{blue}{n2}{\vdash_{L} x} \colorIt{orange}{n3}{: \tau }}
{\colorIt{green}{n4}{\Gamma(x) = \tau}}
    &
\infer[(\textsc{local\ num})]
{\Gamma \vdash_{L} n : int }
    {}
\end{tabular}
\end{center}

\pause

Non-local Expressions: $\Gamma \vdash e : \tau \Rightarrow \gamma$
%Non-local Expressions: $\colorIt{red}{n1}{\Gamma } \colorIt{blue}{n2}{\vdash e } \colorIt{orange}{n3}{: \tau \Rightarrow \gamma}$
\pause
\vspace{-0.1in}
\begin{center}
\begin{tabular}{c}
\infer[(\textsc{deref})]
{\colorIt{red}{n1}{\Gamma} \colorIt{blue}{n2}{\vdash *e } \colorIt{orange}{n3}{: \tau \Rightarrow \gamma}}
{\colorIt{green}{n4}{\colorIt{red}{n5}{\Gamma} \colorIt{blue}{n6}{\vdash e} \colorIt{orange}{n7}{: \text{ref } \tau \Rightarrow \gamma}}}
\end{tabular}
\end{center}

\pause

Commands: $\Gamma \vdash c \Rightarrow c'$
%Commands: $\colorIt{red}{n1}{\Gamma } \colorIt{blue}{n2}{\vdash c } \colorIt{orange}{n3}{\Rightarrow c'}$
\vspace{-0.1in}
\pause
\begin{center}
\begin{tabular}{c}
\infer[(\textsc{var\ write})]
{\colorIt{red}{n1}{\Gamma } \colorIt{blue}{n2}{\vdash x \coloneqq e } \colorIt{orange}{n3}{\Rightarrow \text{assert}(\bigwedge_{y \in \text{Dom}(\Gamma)}\gamma_y);\ x \coloneqq e }}
{\colorIt{green}{n4}{x \in \text{Dom}(\Gamma)} \qquad
  \colorIt{green}{n8}{\forall(y:\tau_y) \in \Gamma,\ \colorIt{red}{n5}{\Gamma } \colorIt{blue}{n6}{\vdash y[e/x]} \colorIt{orange}{n7}{:\tau_y[e/x] \Rightarrow \gamma_y }}}
\end{tabular}
\end{center}

\pause
\end{frame}

\begin{frame}{The Interesting Rules}
Dereferencing
\begin{center}
\begin{tabular}{c}
\infer[(\textsc{array\ deref})]
{\Gamma \vdash *e; \tau \Rightarrow \gamma_e \wedge (0 < e_{len})}
{\Gamma \vdash e: \text{array } \tau \ e_{len} \Rightarrow \gamma_e}
\end{tabular}
\end{center}

\vspace{0.1in}
\pause

Arithmetic
\begin{center}
\begin{tabular}{c}
\infer[(\textsc{array\ arith})]
{\colorIt{red}{n1}{\Gamma} \colorIt{blue}{n2}{\vdash e + e'} \colorIt{orange}{n3}{: \text{array } \tau\ (e_{len} - e') \Rightarrow \gamma_e \wedge \gamma_e' \wedge (0 \leq e' \leq e_{len})}}
{\colorIt{green}{n7}{\colorIt{red}{n4}{\Gamma} \colorIt{blue}{n5}{\vdash e} \colorIt{orange}{n6}{: \text{array } \tau\ e_{len} \Rightarrow \gamma_e}}
 \quad \colorIt{green}{n8}{\colorIt{red}{n9}{\Gamma} \colorIt{blue}{n10}{\vdash e'} \colorIt{orange}{n11}{:\text{int} \Rightarrow \gamma_{e'}}}}
\end{tabular} 
\end{center}

\end{frame}
% var-write is a key contribution of type system
% $\textsc{var\ write}$ rule responsible for updates to variables in presence of dependent type variables, verifying assignment does not break any dependencies in current scope
% For example, we can add rules for arrays:
% also permits a coercion judgement for allowing an array to be used where a smaller one is expected
% todo how are constraints solved during phase 3?

% todo if time
%\begin{frame}[fragile]{Revisiting that Deputy Example}
%\begin{columns}[T]
%\begin{column}{0.45\textwidth}
%\begin{lstlisting}[
%    language=C,numbers=left,mathescape,basicstyle={\scriptsize\ttfamily},
%    moredelim={**[is][{\btHL[onslide=<3->{fill=blue!50}]}]{@3}{@}},
%    moredelim={**[is][{\btHL[onslide=<4->{fill=blue!50}]}]{@4}{@}},
%    moredelim={**[is][{\btHL[onslide=<5->{fill=blue!50}]}]{@5}{@}},
%    moredelim={**[is][{\btHL[onslide=<6->{fill=red!50}]}]{@6}{@}},
%    moredelim={**[is][{\btHL[onslide=<7->{fill=red!50}]}]{@7}{@}},
%    moredelim={**[is][{\btHL[onslide=<8->{fill=red!50}]}]{@8}{@}},
%    moredelim={**[is][{\btHL[onslide=<9->{fill=red!50}]}]{@9}{@}},
%]
%int find_token(int * @3bound(cur, end)@ data,
%               int * @4sentinel@ end,
%               int token)
%{
%    @6assert(data != NULL);@
%    @6assert(end != NULL);@
%    int *p @5bound(cur, end)@ = data;
%    while (p < end) {
%        @7assert(p != NULL);@
%        @7assert(p < end);@
%        if (*p == token) break;
%        @8assert(p <= p + 1 <= end);@
%        p++;
%    }
%    @9assert(p != NULL);@
%    @9assert(p < end);@
%    return (*p == token);
%}
%\end{lstlisting}
%\end{column}
%
%\pause
%
%\begin{column}{0.45\textwidth}
%    \todo{add explanation of use of rules}
%\end{column}
%
%\end{columns}
%\end{frame}

\begin{frame}{Dependent Types in Imperative Languages}
%Low-Level Liquid Types (LTLL) \footcite{rondon_low-level_2010}
%\begin{itemize}
%    \item Refinement types where predicates are conjunctions over qualifiers
%    \item Functions qualified over locations they operate on
%    \item Deal with collections using \emph{location folding} for checking out a copy to do strong updates on
%    \item Tries to deal with lack of types, mutation, unbounded collections that make type-based mechanisms difficult
%\end{itemize}

T\'yr \footcite{de_araujo_tyr:_2016}
\vspace{-0.1in}
\begin{itemize}
    \item Augments LLVM IR with dependent pointer types
    \item Uses programmer annotations insert run-time bounds checks
    \item LLVM optimizations remove always-true checks; error if always-false
\end{itemize}

\pause

Checked C \footcite{ruef_checked_2017}
\vspace{-0.1in}
    \begin{itemize}
%        \item Focus on interoperablity, usability, performance
%        \item Discovers safely-used ptrs, rewriting them to be checked
%        \item Normal C pointers
        \item Extend C with two \emph{checked pointer types}: $\texttt{\_Ptr<T>}$ and $\texttt{\_Array\_ptr<T>}$ \note{automatically rewrite code to use when possible; no change to pointers}
        \item Associated bounds expressions indicating where bounds are stored
        \item Isolate (un)safe code with \emph{checked code regions}  \note{prevent unchecked pointer usage and certain casts, at file/func/block level; cannot blame checked code for violations}
%        \item Cannot blame checked code for violation
%        \item Derefence-only (no arith.) pointer, arithmetic-supporting (possibly null-terminated) pointer with bounds in type
%        \item $\verb{_Ptr<T>}$, a pointer for dereference only (no arith)
%        \item $\verb{_Array_ptr<T>}$ and $\verb{_Nt_array_ptr<T>_}$, supporting arith w/ bounds declarations in type (latter is null-terminated)
%       \item Compiler confirms restrictions maintained, inserts checks on ptr access
    \end{itemize}

\pause

Low* \footcite{protzenko_verified_2017}
\vspace{-0.1in}
\begin{itemize}
    \item DSL for verified, efficient low-level programming in F* %(ML-like language with dependent types)
    \item Write F* syntax against library modelling lower-level view of C memory
\end{itemize}
\vspace{0.1in}
\end{frame}
\note[itemize]{
\item Translate Low* to CompCert Clight
\item Goal: write efficient \& verified C in a high-level language
\item Model arrays by implementation abstract buffer type using references by hyper-stacks
}

\begin{frame}{Quick Spatial Recap}
Spatial Safety
\begin{itemize}
    \item Arrays and pointers \note{Unsafe languages like C conflate arrays and pointers, casts eliminate any semblance of type guarantees, types are just for size}
    \item Undecidable \note{Completely detecting buffer overflow in general is undecidable, so we try runtime things}
    \item Fat pointers \note{complete spatial safety at cost of compatibility}
    \item Referent objects \note{partial safety and better compatibility}
    \item Dependent types \note{prove in-bounds access at compile-time, emit run-time checks for full safety}
%    \item Solution% seems to be
%        \begin{itemize}
%            \item Restrict C
%            \item Limited form of bounds type information
%            \item Constraint solving
%            \item Runtime checks
%        \end{itemize}
\end{itemize}
\end{frame}

\section{Temporal Safety}

\begin{frame}[fragile]{Temporal Safety}
Prevent accessing object that has been \emph{previously deallocated}
\\
\pause

\begin{itemize}
   \item Capability store
   \item Effects and regions
   \item Linear types, ownership, and borrowing
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Temporal Safety Example}
\begin{columns}[T]
\begin{column}{0.52\textwidth}
\begin{lstlisting}[
    language=C,numbers=left,mathescape,basicstyle={\scriptsize\ttfamily},
    moredelim={**[is][{\btHL<1>}]{@1}{@}},
    moredelim={**[is][{\btHL<2>}]{@2}{@}},
    moredelim={**[is][{\btHL<3>}]{@3}{@}},
    moredelim={**[is][{\btHL<4>}]{@4}{@}},
    moredelim={**[is][{\btHL<5>}]{@5}{@}},
    moredelim={**[is][{\btHL<6>}]{@6}{@}},
    moredelim={**[is][{\btHL<7>}]{@7}{@}},
    moredelim={**[is][{\btHL<8>}]{@8}{@}},
    moredelim={**[is][{\btHL<9>}]{@9}{@}},
    moredelim={**[is][{\btHL<10>}]{@10}{@}},
    moredelim={**[is][{\btHL<11>}]{@11}{@}},
    moredelim={**[is][{\btHL<12>}]{@12}{@}},
]
@1int attach(struct sock *sk) {@
@2    if (sk->bad) {@
@3        free(sk); return 1;@
    }
@4    return 0;@
}
@5void mq_notify(sigevent *n) {@
@6    struct sock_t *sock;@
@7    while (n->try) {@
@8        sock = malloc_sock(n->info);@
@9        if (attach(sock) == 0){@
@12            sock = NULL;@
@10            break;@
        }
    }
@11    if (sock) free(sock);@
}
\end{lstlisting}
\end{column} 
\begin{column}{0.44\textwidth}

\footnotesize{
\onslide<13->
Potential pointer dereference problems:
  \begin{itemize}
      \item Double frees
      \item Dangling pointers
  \end{itemize}
\pause

\onslide<14->
A Real Bug
 \begin{itemize}
    \item Linux Kernel in \texttt{ipc/mqueue.c}
    \item July 2017
    \item \url{https://bugzilla.redhat.com/show_bug.cgi?id=1470659}
  \end{itemize}

\pause

\onslide<15->
Goals:
\begin{itemize}
    \item Good: Detecting use-after-free
    \item Better: Eliminating free entirely \note{so 'use-after' has no meaning}
\end{itemize}
}
\end{column}
\end{columns}

\end{frame}

\begin{frame}{A Comment on Garbage Collection}
Garbage collection
\pause
    \begin{itemize}[<+->]
        \item Relinquish control of object location and layout to runtime \note{disallow free}
        \item Complete temporal safety, but...
        \begin{itemize}
            \item Non-zero overhead
            \item Drag
            \item Loss of real-time guarantees/predictability
            \item Reduced reference locality, increased page fault/cache miss rates
        \end{itemize}
        %\item Non-zero overhead, sub-par memory use (drag) \note{time between unreachable and reclaimed}
        \item Some spatial approaches (e.g. Fail-Safe C, CCured etc.) use Boehm-Demers-Weister \footcite{boehm_garbage_1988})
           \note{heapify local variables (prevent dangling ptrs to stack objects) so they are managed by GC}
        %\item Others like Cling \footcite{akritidis_cling:_2010} rely on a special allocators % TODO
        %    \note{Replace malloc: address space re-use only among objects of same type and alignment (type-safe memory re-use)}
    \end{itemize}
\end{frame}
% \footcite{austin_efficient_1994}
% \footcite{jones_backwards-compatible_1997}
% \footcite{xu_efficient_2004}

\subsection{Capabilities and Locks}

\begin{frame}{Capabilities and Locks}
    \pause
    \begin{itemize}
        \item SafeC, MSCC %, Patil 1997, Yong 2003
            \begin{itemize}
              \item Unique capability associated with each memory block
              \item Stored in capability store, marked invalid on free
              \item Check if pointer's capability copy is still valid on dereference
            \end{itemize}
        \pause
        \item CETS \footcite{nagarakatte_cets:_2010}\footcite{nagarakatte_everything_2015}
            \begin{itemize}
                \item Each allocation has unique (never reused) key and lock address \note{key associated with all pointers to object}
                \item Freeing allocated object changes value at lock location, invaliding pointers to it, so key and lock value don't match
            \end{itemize}
        \pause
        \item Memsafe \footcite{simpson_memsafe:_2013}
            \begin{itemize}
                \item Set bounds of deallocated pointer to invalid value % subsequent dereferences raise exception as bounds is invalid
            \end{itemize}
    \end{itemize}
\end{frame}
% (Zorn: measured cost of conservative GC: 1993)
%    * [ ] Lee "Preventing use-after-free with dangling ptrs" 2015

\begin{frame}[fragile]{Capability Example}

\begin{columns}[T]
\begin{column}{0.48\textwidth}
\end{column}
\begin{column}{0.48\textwidth}
    % TODO
\begin{lstlisting}[
    language=C,numbers=left,mathescape,basicstyle={\scriptsize\ttfamily},
    moredelim={**[is][{\btHL<1>}]{@1}{@}},
    moredelim={**[is][{\btHL<2>}]{@2}{@}},
    moredelim={**[is][{\btHL<3>}]{@3}{@}},
    moredelim={**[is][{\btHL<4>}]{@4}{@}},
    moredelim={**[is][{\btHL<5>}]{@5}{@}},
    moredelim={**[is][{\btHL<6>}]{@6}{@}},
    moredelim={**[is][{\btHL<7>}]{@7}{@}},
    moredelim={**[is][{\btHL<8>}]{@8}{@}},
    moredelim={**[is][{\btHL<9>}]{@9}{@}},
    moredelim={**[is][{\btHL<10>}]{@10}{@}},
    moredelim={**[is][{\btHL<11>}]{@11}{@}},
    moredelim={**[is][{\btHL<12>}]{@12}{@}},
]
int attach(struct sock *sk) {
    if (sk->bad) {
        free(sk); return 1;
    }
    return 0;
}
void mq_notify(sigevent *n) {
    struct sock_t *sock;
    while (n->try) {
        sock = malloc_sock(n->info);
        sock_key = Next_key++;
        sock_lock_addr = allocate_lock();
        *(sock_lock_addr) = sock_key;
        Freeable_ptrs_map.insert(sock_key, sock);
        if (attach(sock) == 0){
            sock = NULL;
            break;
        }
    }
    if (sock) free(sock);
}
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}

\subsection{Effects and Regions}

%\begin{frame}{The Question}
%Can we get the \alert{compiler} to do the memory deallocation for us? % will require a restriction of paradigms/cooperation by the programmer
%\\
%\vspace{0.2in}
%Can we statically determine the lifetimes of all values? \note{like automatic variables put on/popped off stack}
%\end{frame}
\note[itemize]{
  \item Can we get the \alert{compiler} to do the memory deallocation for us? % will require a restriction of paradigms/cooperation by the programmer
  \item Can we statically determine the lifetimes of all values? \note{like automatic variables put on/popped off stack}
  \item let's begin with effects and regions
}

\begin{frame}{Effects}
    Effect types describe the \emph{effects} of the computation leading to a value \footcite{pierce_advanced_2005}
    \\
    \begin{itemize} % you could imagine describing a procedure that...
        \item Opening a file
        \item Modifying an object
        \item \todo{fill me in}
    \end{itemize}
\end{frame}

\begin{frame}{Effects}
    Fluent Languages\footcite{gifford_integrating_1986}, MFX\footcite{lucassen_polymorphic_1988}
  \begin{columns}[T]
    \begin{column}{0.68\textwidth}
        \begin{itemize}[<+->]
            \item Mix functional and imperative languages \note{determine which can be parallelized}
            \item Every expression has a \alert{effect class}, restricting which subroutines or sublanguage features it may use
            \item Identify \alert{referentially transparent} expressions via a side effect lattice \note{memoizable, for concurrency}
            \item Effect masking: inference to delimit regions of memory and their lifetimes
            %\item side-effects that cannot be observed outside of a given expression can be masked by the effect system
            %\item effect masking lets imperative program fragments be embedded in functional programs
        \end{itemize}
    \end{column}

    \pause

    \begin{column}{0.30\textwidth}
    \vspace{-0.2in}
    \footnotesize{
    \begin{tikzpicture}
        \node (WRA) at (0,3) {$\{W\ (R)\ (A)\}$};
        \node (RA)  at (0,2) {$\{R\ (A)\}$};
        \node (A)   at (0,1) {$\{A\}$};
        \node (e)   at (0,0) {$\{\}$};
        \node[draw] at (2,3) {$\text{Procedure}$};
        \node[draw] at (1.95,2) {$\text{Observer}$};
        \node[draw] at (1.95,1) {$\text{Function}$};
        \node[draw, right= of e] {$\text{Pure}$};
      \draw (e) -- (A) -- (RA) -- (WRA);
    \end{tikzpicture}

    \vspace{0.1in}
    \pause
    E.g.
    \begin{itemize}
        \item \texttt{update} is Procedure
        \item \texttt{nth} is Observer
        \item \texttt{arrayCreate} is Function
        \item \texttt{length} is Pure
    \end{itemize}
    }
    \end{column}
  \end{columns}
  \vspace{-0.3in}
\end{frame}
\note[itemize]{
% fluent
\item observer: not cause side-effects; cannot perform assignments or call procedure
\item function: not cause side-effcts, value is not affected by side-effects; no assignments, cannot call up, cannot access update-able variables
\item pure: referentially transparent: does not cause side-ffects, value not affected by side-effects, returns same value each time evaluated
\item pure:  no asignments, no accessing updating variables, cannot allocate updateable variables
\item cannot call UP the lattice
% MFX:
\item show soundness of effect type system for FX language
\item use effect information to constraint parallel evaluation of expressions
\item effect-masking: side-effects taht cannot be observed outside of the given expression
\item show how type and effect info can be used to implement certain kinds of side-effect analyses
\item language extends work with:
\item effect classes
\item full abstraction over effects
\item unmaskable side-effects
\item soundness proof
}

\begin{frame}{Effects}
    Type and Effect Systems \footcite{nielson_type_1999}
    \begin{itemize}[<+->]
        \item Extend the simply-typed lambda calculus with annotations
        \item Various forms of analyses, incl. Side Effect Analysis and \alert{Region} Inference
    \end{itemize}

    \pause

%\begin{gather*}
%    x \in \text{Variables}
%    \quad
%    c \in \text{Constants}
%\end{gather*}

\vspace{-0.2in}
\begin{alignat*}{2}
    \text{Exprs}\quad &e &&::= c \altm x \altm \texttt{fn}_{\pi}\ x\ \Rightarrow e_0 \altm e_1\ e_2 \onslide<5->{\altm \texttt{new}_{\pi}\ x\ :=\ e_1\ \texttt{in}\ e_2} \onslide<6->{\altm!x} \onslide<7->{\altm x := e_0}
\\
    \text{Types}\quad &\tau &&::= \texttt{int} \altm \texttt{bool} \only<4-8>{\altm \tau_1 \rightarrow \tau_2} \only<9->{\altm \tau_1 \xrightarrow[]{\phi} \tau_2} \only<8>{\altm \tau\ \texttt{ref}} \only<9->{\altm \tau\ \texttt{ref}\ \varrho}
\onslide<10->{\\ \only<10-11>{\text{Effect}}\only<12->{\colorIt{blue}{n1}{\text{Region}}}\quad &\phi &&::= \{!\pi\} \altm \{\pi:=\} \altm \{\texttt{new}\ \pi\} \altm \phi_1 \cup \phi_2 \altm \emptyset}
\onslide<11->{\\ \text{PrgPts}\quad &\varrho &&::= \{\pi\} \altm \varrho_1 \cup \varrho_2 \altm \emptyset}
\end{alignat*}

\onslide<13->{
\begin{center}
    $\Gamma \vdash e\ :\ \tau \ \&\ \phi$
\end{center}
}

\vspace{0.1in}
\end{frame}
\note[itemize]{
\item region inference: compile-time determination of when to allocate regions, in which to allocate data
\item Ref. variable represented by set of points where it could have been created (\alert{region})
\item Annotate functions with actions they take (access, assignment, creation)
\item we call \pi the creation point
\item \tau ref \varrho is type of loc created at one of the program points in region \varrho
}

% BitC \footcite{shapiro_origins_2008} % a retrospective on BitC, what they were looking for (not too interesting)

\begin{frame}{Region-Based Memory Managememt}
    Regions \footcite{tofte_region-based_1997}
    \begin{itemize}[<+->]
        \item Divide heap into stack of sub-heaps (i.e. regions) \note{unbounded subheaps}
        \item Regions grow on individual allocation; \alert{entire} region deallocated \note{no individual object deallocation}
        \item Explicit region polymorphism \note{regions can be given as arguments to functions at runtime}
        \item Sound type system \alert{guarantees safety} of deallocations \note{both alloc and dealloc are explicit}
        \item Region inference identifies:
            \begin{itemize}
                \item Points where entire regions are allocated and deallocated
                \item Into which region values should go
            \end{itemize}
        %\item Used in ML Kit
        \item Unreasonable object lifetimes due to LIFO ordering of region lifetimes %(lifetime of expression must coincide with time takes to execute some subexpression)
        %\item new regions must be removed before older ones (but you can put a value in any region)
    \end{itemize}
    \vspace{0.1in}
\end{frame}

\begin{frame}{Early Use of Regions}
    \footnotesize{
Capability Calculus \footcite{crary_typed_1999}
    \vspace{-0.1in}
    \begin{itemize}
        %\item Add aliasing info to capabilities; track copies to know when truly revoked
        %\item capability: indicates set of regions presently valid to access
        \item Arbitrarily-ordered region allocation/deallocation, via capability tracking \note{capability: set of regions presently valid to access}
    \end{itemize}
\pause
% Goal: realistic region support for C, but don't give tons of safety guarantees: more to help
%       b/c they allow arbitrary region intermingling, they need reference counts
RC \footcite{gay_language_2001}
    \vspace{-0.1in}
   \begin{itemize}
     %\item Region-support for C, focus on preventing dangling pointers % aliasing!
     \item Maintain a reference count of external pointers pointing to objects in region % deleteregion fails if count is zero
     %\item Type system + annotations ($\texttt{sameregion}, \texttt{traditional}, \texttt{parentptr}$) to help compiler remove annotation operations % no updating associated region % enforced by runtime checks
     %\item Annotations ($\texttt{sameregion}, \texttt{traditional}, \texttt{parentptr}$) to prevent updating associated region % enforced by runtime checks
     %\item Restrict C by disallowing arbitrary integer-to-pointer casts
     %\item Break cyclic data structures before deleting regions
%     \item \alert{No} memory safety guarantee
% \item 27%-11% overhead
   \end{itemize}
\pause
Reaps \footcite{berger_reconsidering_2002}
    \vspace{-0.1in}
   \begin{itemize}
     \item Combine regions and heaps into ``reaps''; regions until $\texttt{reapFree}$ deallocates individual object
%     \item Place freed object on a heap; subsequent allocations use heap until exhausted
%     \item Use Lea allocator generally, unless you need fast regions (i.e. reaps) % what their study found
   \end{itemize}

Control-C \footcite{kowshik_ensuring_2002}
    \vspace{-0.1in}
    \begin{itemize}
        \item Single region active at any given time
%        \item Pointer value containing region address must be provably dead before \texttt{rfree}
        \item Automatic Pool Allocation and Type Homogeneity \footcite{dhurjati_memory_2003} for safe dangling pointers \note{objects represented by the same points-to graph node are allocated in a common pool; can individually deallocate}
    \end{itemize}
}
    \vspace{0.2in}
\end{frame}

\begin{frame}{Regions in Cyclone}
    Cyclone\footcite{grossman_region-based_2002}, again!
    \begin{itemize}[<+->]
        % lexically-scoped: i.e. region x { int i<x> = 5; ... }
        \item Three region types:
            \begin{itemize}
                \item single \alert{heap} region \note{(lives forever)}
                \item \alert{stack} regions \note{(local-declaration blocks)}
                \item \alert{dynamic} regions \note{(lexically-scoped lifetimes)}
            \end{itemize}
        % heap region: lives forever, can be garbage collected
        \item Region polymorphism
        %\item Annotate pointers with regions into which they point; must be live for dereference
        \item Lifetime subtyping: region A <: region B $\Leftrightarrow$ region A \alert{outlives} region B
        %\item Can specify partial orders on region lifetimes between pointers
        \item Sane defaults by inferring region annotations on pointer types  % intraprocedural analysis => need function prototypes
    \end{itemize}
    \vspace{0.1in}
\end{frame}

\begin{frame}[fragile]{Regions in Cyclone}
\footnotesize

  \begin{columns}[T]
    \begin{column}{0.52\textwidth}
      \begin{itemize}[<+->]
        \item Pointer can escape scope of their regions \note{via closures/existential types; RC dealt with this via reference counting}
        \item Type system tracks \alert{capability} (live regions set)
        \item Check needed \alert{liveness} on pointer dereference % no closures, but existential types can hide pointers to escape scope of their regions
        \item Function \alert{effect}: set of regions it might access
        \item Calculate function's effect from prototype alone
        %\item Type of elements not known, so use $\epsilon$ to abstract set of regions it might need to access
        \item Fix with static operator $\texttt{regions\_of}$ %instead of effect variables % TODO review what effect variables are
      \end{itemize}
    \end{column}

\begin{column}{0.46\textwidth}

    \pause

\begin{lstlisting}[language=C,numbers=left,mathescape,basicstyle={\footnotesize\ttfamily}]
struct Set<$\alpha$, $\rho$, $\epsilon$>
{
  list_t<$\alpha$, $\rho$> elts;
  int (*cmp)($\alpha$,$\alpha$; $\epsilon$);
}
\end{lstlisting}

\pause

\begin{lstlisting}[language=C,numbers=left,mathescape,basicstyle={\footnotesize\ttfamily}]
struct Set<$\alpha$, $\rho$>
{
  list_t<$\alpha$, $\rho$> elts;
  int (*cmp)($\alpha$,$\alpha$; regions_of($\alpha$));
}
\end{lstlisting}

\end{column}
\end{columns}

\end{frame}

\begin{frame}{Some Cyclone Abstract Syntax}
\scriptsize{
\begin{alignat*}{2}
\text{kinds}\quad &\kappa &&::= T \altm R
\\
\text{type and region vars}\quad &\alpha,\rho &&
\\
\text{region sets}\quad &\epsilon &&::= \emptyset \altm \alpha_n \epsilon_1 \cup \epsilon_2
\\
\text{region constraints} \quad &\gamma &&::= \emptyset \altm \gamma, \epsilon <: \rho
\\
%\text{constructors} \quad &\tau &&::= \alpha \altm \text{int} \altm \tau_1 \xrightarrow[]{\epsilon} \tau_2 \altm \tau_1 \times \tau_2 \altm \tau \ast \rho \altm
%\\
%~ & ~ && \qquad \text{handle}(\rho) \altm \forall\alpha:\kappa \triangleright \gamma.\tau \altm \exists \alpha:\kappa \triangleright \gamma.\tau
%\\
\text{constructors} \quad &\tau &&::= \alpha \altm \text{int} \altm \tau_1 \xrightarrow[]{\epsilon} \tau_2 \altm \tau @ \rho \altm \text{handle}(\rho) \altm \forall\alpha:\kappa \triangleright \gamma.\tau \altm ...
\\
%\text{expressions} \quad &e &&::= x_\rho \altm v \altm e\ \langle\tau\rangle \altm (e_1,e_2) \altm e.i \altm \ast e \altm \textbf{rnew}(e_1)e_2 \altm
%\\
%~ & ~ && \qquad e_1(e_2) \altm \&e \altm e_1 = e_2 \altm \textbf{pack} [\tau_1, e]\textbf{ as } \tau_1
%\\
\text{expressions} \quad &e &&::= x_\rho \altm v \altm e\ \langle\tau\rangle \altm \ast e \altm \textbf{new}(e_1)e_2 \altm e_1(e_2) \altm \&e \altm ...
\\
%\text{values} \qquad &v &&::= i \altm f \altm \&p \altm \textbf{region}(\rho) \altm (v_1, v_2) \altm \textbf{pack}[\tau_1,v]\textbf{ as } \tau_2
%\\
%\text{values} \qquad &v &&::= i \altm f \altm \&p \altm \textbf{region}(\rho) \altm ...
%\\
%\text{paths} \qquad &p &&::= x_\rho \altm p.i
%\\
\text{functions} \qquad &f &&::= \rho:(\tau_1\ x_{\rho}) \xrightarrow[]{\epsilon} \tau_2 = \{s\} \altm \Lambda\alpha:\kappa \triangleright \gamma.f
\\
%\text{statements} \qquad &s &&::= e \altm \textbf{return } e \altm s_1;s_2 \altm \textbf{if } (e)\ s_1 \textbf{ else } s_2 \altm \textbf{while } (e)\ s \altm
%\\
\text{statements} \qquad &s &&::= e \altm s_1;s_2 \altm \textbf{if } (e)\ s_1 \textbf{ else } s_2 \altm \rho:\{\tau\ x_\rho = e;\ s\} \altm \textbf{region}\langle\rho\rangle\ x_{\rho}\ s \altm ...
\\
...
\end{alignat*}
    }
\end{frame}

% TODO make a tikzpicture explaining/pointing to each part of judgment
\begin{frame}{Example Cyclone Judgments}
  \begin{columns}[T]
    \begin{column}{0.32\textwidth}
     $\Delta;\Gamma;\gamma;\epsilon;\tau \vdash_{stmt} s$
    \end{column}
    \begin{column}{0.32\textwidth}
     $\Delta;\Gamma;\gamma;\epsilon \vdash e\ :\ \tau$
    \end{column}
    \begin{column}{0.32\textwidth}
     $\Gamma \vdash \epsilon \Rightarrow \rho$
    \end{column}
  \end{columns}

\pause

$\Delta: \text{in-scope type/region vars}$
\pause
\\
$\Gamma: \text{mapping of in-scope vars to types}$
\pause
\\
$\gamma: \text{constraints relating lifetimes}$
\pause
\\
$\epsilon: \text{capability, i.e. live regions}$
% Delta holds type and region variables in scope
% Gamma holds value variables in scope and types
% \gamma records partial order constraints relating region lifetimes
% \epsilon records capability (which regions in \Delta are live)
% tau is type e must have in any statement of form return e
\pause

% expressions access memory can be proven to be live from epsilon and gamma
\begin{center}
\begin{tabular}{cc}
\infer[(\textsc{var})]
{\Delta;\Gamma;\gamma;\epsilon \vdash x_\rho : \Gamma(x_\rho)}
{\gamma \vdash \epsilon \Rightarrow \rho}
    &
\infer[(\textsc{deref})]
{\Delta;\Gamma;\gamma;\epsilon \vdash \ast e:\tau}
{\Delta;\Gamma;\gamma;\epsilon \vdash e:\tau \ast \rho \qquad \gamma \vdash \epsilon \Rightarrow \rho}
\end{tabular}

\pause
\vspace{0.1in}

% every alpha and rho in epsilon_1 can be proven live from epsilon and gamma
\begin{tabular}{c}
\infer[(\textsc{call})]
{\Delta;\Gamma;\gamma;\epsilon \vdash e_1(e_2):\tau}
{\Delta;\Gamma;\gamma;\epsilon \vdash e_1 : \tau_2 \xrightarrow[]{\epsilon_1} \tau
    \qquad
 \Delta;\Gamma;\gamma;\epsilon \vdash e_2 : \tau_2 
    \qquad
 \gamma \vdash \epsilon \Rightarrow \epsilon_1}
\end{tabular}

\pause
\vspace{0.1in}

% type instantiation
\begin{tabular}{c}
\infer[(\textsc{type-inst})]
{\Delta;\Gamma;\gamma;\epsilon \vdash e\langle\tau_1\rangle: \tau_2[\tau_1 / \alpha]}
{\Delta;\Gamma;\gamma;\epsilon \vdash e : \forall\alpha:\kappa\triangleright\gamma_1 . \tau_2
    \qquad
 \Delta \vdash \tau : \kappa
    \qquad
 \gamma \vdash \gamma_1[\tau_1 / \alpha]}
\end{tabular}

% TODO review this
% novelty: ensuring gamma establishes constraints \gamma_1 used when type-checking e
% judgement \gamma \vdash \gamma' means for every \epsilon <: \rho in \gamma', we can show \gamma \vdash \rightarrow \epsilon
% \tau_2[\tau_2/alpha] is capture-avoiding substitution of \tau_1 for \alpha in \tau
% \gamma_1[\tau_1/alpha] is substitution of regions_of(\tau_1) for \alpha in \gamma_1

\end{center}
\end{frame}

\begin{frame}[fragile]{Regions Example}
\todo{replace with my running example}
\footnotesize{
  \begin{columns}[T]
    \begin{column}{0.48\textwidth}
% TODO note that char? is a [fat/array] pointer, so it will do checks of bounds inside]
\begin{lstlisting}[language=C,mathescape,basicstyle={\scriptsize\ttfamily}]
// Example prototypes
char?$\rho_1$ strcpy<$\rho_1$,$\rho_2$>(char?$\rho_1$ d,
  const char ?$\rho_2$ s);
char?$\rho_H$ strdup<$\rho$>(const char?$\rho$ s);
char?$\rho$ strlen<$\rho$>(const char?$\rho$ s);

// Dangling pointer prevention
int *$\rho_L$ p;
L:{ int x = 0;
    p = &x;
  }
*p = 42;
\end{lstlisting}
    \end{column}
%
%// Region polymorphism
%L:{ char buf[20];
%    strcpy<$\rho_L$,$\rho_H$>(buf, "a heap pointer"); }

    \begin{column}{0.48\textwidth}
\begin{lstlisting}[language=C,mathescape,basicstyle={\scriptsize\ttfamily}]
// Polymorphic Recursion
void fact<$\rho$>(int*$\rho$ result, int n) {
 L: { int x = 1;
      if (n > 1) fact<$\rho_L$>(\&x,n-1);
      *result = x*n; }
}
int g = 0;
int main() { fact<$\rho_H$>(\&g, 6); return g; }
\end{lstlisting}
    \end{column}
    \end{columns}
}
%
%// Type definitions
%struct Lst<$\rho_1$, $\rho_2$> {
%    int*$\rho_1$ hd;
%    struct Lst<$\rho_1$, $\rho_2$> *$\rho_2$ tl;
%};
\end{frame}

\begin{frame}{Cyclone Results}
Soundness Theorem \footcite{grossman_formal_2001}:
    \begin{itemize}
        \item The program cannot get stuck from type errors or dangling-pointer dereferences. 
        %\item If starting statement is well-formed with respect to initial heap, the program cannot get stuck from type errors or dangling-pointer dereferences. 
        \item The terminating program deallocates all regions it allocates \note{non-vacuous -- it's saying b/c it did its job right}
    \end{itemize}
    % can compile with GC
\pause
Benchmarks
    \begin{itemize}
        \item 86 lines of region annotation-related changes across 18,000 lines (6\%) \note{change 10\% of code)}
        \item Eliminate heap allocation entirely for web-server
        \item Near-zero overhead (from garbage collection and bounds checking)
    \end{itemize}
\end{frame}


\subsection{Linear Types and Ownership}

% introduce
\begin{frame}{Linear Types}
    Linear types \footcite{girard_linear_1987}\footcite{wadler_linear_1990} ensure that every variable is used exactly \emph{once}.
    \begin{itemize}[<+->]
        %\item Cannot be arbitraily copied or discarded \note{i.e. allow exchange, not weakening or contraction}
        \item \emph{The world} is a non-duplicatable resource % don't want to world states at same time
        \item Track proper modification of world % (modelled as an array)
        \item Efficiency: safe to destructively update an array
        \item $\textbf{Memory management: can immediately collect used values}$ % only one reference, can show memory management does not leak
        %\item Many read-only references (non-linear), only one reference (linear) for writing %not at same time; write must be only reference
        %\item Paper shows how linear types can determine when an array's update operation can re-use storage in a safe way
    \end{itemize}
\end{frame}
% mention girard's linear logic

%\begin{frame}{Linear Types}
%\begin{alignat*}{2}
%    \text{Exprs}\quad &e &&::= c \altm x \altm \texttt{fn}_{\pi}\ x\ \Rightarrow e_0 \altm e_1\ e_2 \altm \texttt{new}_{\pi}\ x\ :=\ e_1\ \texttt{in}\ e_2 \altm!x \altm x := e_0
%\\
%    \text{Types}\quad &\tau &&::= \texttt{int} \altm \texttt{bool} \altm \tau_1 \rightarrow \tau_2 \altm \tau\ \texttt{ref}
%\end{alignat*}
%\end{frame}

\begin{frame}{Applied Linear Types}
\footnotesize{
Clay \footcite{hawblitzel_low-level_2004}
  \begin{itemize}
    \item Type-theoretic basis for giving type-safe code more control over memory
    \item Singleton types to type check loads, coercion functions to modify values' type safely
    %\item Memory is single linear array words, linearity prevents aliasing
    %\item Type sequences to safely introduce non-linearity % todo review this
    %\item Used to implement several GCs
  \end{itemize}

\pause

$\textsc{PACLANG}$ \footcite{ennals_linear_2004} %: packet processing
  \begin{itemize}
    \item Program network processors for handling packets % with linear type system
    \item Unique ownership property: each packet in heap is referenced by exactly one thread
    \item Allow mutable aliasing within the same thread
    \item Operations for a functions to 1) take ownership or 2) create local aliases
  \end{itemize}
}
\end{frame}

\begin{frame}{COGENT}
    $\textsc{cogent}$ \footcite{amani_cogent:_2016}\footcite{oconnor_cogent:_2016}
    \begin{itemize}[<+->]
        \item Pure, polymorphic language with linear types for writing low-level systems code \note{high-level; filesystems}
        \item Efficient machine code with in-place updates
        %\item Imperative C semantics and functional value semantics \note{the linear types; for equational reasoning}
        \item Linear types:
            \begin{itemize}
                \item Ensure safe handling of heap-allocated objects
                \item Equational functional semantics via mutable state/impeative effects
            \end{itemize}
        \item Reason with \alert{interactive theorem prover}
        \item No trusted compiler, runtime, or garbage collector needed
    \end{itemize}
\end{frame}
% total functions (no recursion)

% TODO fix size, notes to talk about it
\begin{frame}{COGENT}
    $\vcenter{\hbox{\includegraphics[height=18em]{fig/FIGURE_oconnor-2016_cogent-chain.PNG}}}$
\end{frame}

%\notes{
% Their verification chain is extensive.
%Given a $\cogent$ program, the $\cogent$ compiler first generates C code.
%A C parser then generates the semantics of this C code in Isabelle/Simpl (*A*).
%Using the Simple code, the /AutoCoress/ tool generates a monadic functional program (*B*).
%Then the $\cogent$ also produces the following representations:
%  - a monomorphic A-normal /deep/ embedding of the $\cogent$ program (*C*)
%  - a polymorphic A-normal /deep/ embeeded of the same (*D*)
%  - an A-normal /shallow/ embedding (*E*)
%  - a 'neat' /shallow/ embedding (syntactically close to $\cogent$ compiler input) (*F*)
%The chain of verification involves proving that the Simpl semantics (*A*) /refines/ the
%  monadic semantics (*B*), which /refines/ the update and value semantics of the monomorphic
%  deep embedding (*C*), which refines the value semantics of the polymorphic embedding (*D*),
%  which refines the HOL that is equal to the shallow embedding (*E*) and (*F*).
%Finally, user-supplied abstract datatypes (implemented in C) are verified according to the shallow embedding (*F*).
%The only unverified link the chain is output of the C-to-Isabelle parser that becomes Simpl code (*A*).
%
% kinds to determine is type can be freely shared or discarded
%}

% TODO maybe include
%$\vcenter{\hbox{\includegraphics[height=8em]{fig/FIGURE_oconnor-2016_shallow.PNG}}}$

% so you get a guage of the work here
\begin{frame}{COGENT: Not for Faint of Heart}
Person-Months of Work
    \begin{itemize}
        \item Proof Framework: 33.5
        \item Compiler: 10
        \item Proofs: 18 \note{design, formalisation, and proof of Cogent and properties}
    \end{itemize}
Lines (kLOC)
    \begin{itemize}
        \item Isabelle theorems: 17
        \item Compiler: 9.5 \note{of Haskell $\textsc{cogent}$ compiler code}
        \item ext2 Filesystem: 6.5 (Isabelle/HOL: 76.7) \note{cogent}
    \end{itemize}
\end{frame}
\note[itemize]{
  \item A good way forward (embedded low-level DSLs combined with theorem proving)
}

\begin{frame}{Other Linear Types}
  Quasi-linear types \footcite{kobayashi_quasi-linear_1999} % relaxtes linear type strong condition
    \vspace{-0.09in}
    \begin{itemize}
        \item Distinguish between consumed values vs those that may be returned
        \item Use $\kappa$ to control how often a variable of type $\tau^{\kappa}$ is used (many times locally)
    \end{itemize}
\pause
  Vault \footcite{deline_enforcing_2001} % TODO review this, TODO where is best place to put this, it combines typestate with regions like Cyclone...
    \vspace{-0.09in}
    \begin{itemize}
        \item Keys associate static capabilities with run-time resources %, held-key set, type guards
        \item Annotate functions with effect clause (pre- and post-conditions on held-key set)
        \item Windows 2000 locking errors, IRP ownership model % corresponds to tracked types
    \end{itemize}
\pause
  Ordered types for memory layout \footcite{petersen_type_2003}
    \vspace{-0.09in}
    \begin{itemize}
        \item Variables must be used in order $\Rightarrow$ memory locations \note{restrict linear types by removing exchange property} %todo explain this better
        \item \emph{Orderly lambda calculus} for size-preserving memory operations \note{Coercions to manipulate ordered variables in frontier (combine/split to treat as different types)}
    \end{itemize}
  \vspace{0.2in}
\end{frame}

\begin{frame}{Ownership}
\footnotesize
   Types can represent \alert{ownership} and prevent \emph{aliasing} and \emph{mutation} on the same location.
   \\
   \vspace{0.1in}
   \pause
  LCL \footcite{evans_static_1996}
    \vspace{-0.1in}
    \begin{itemize}
        \item $\texttt{owned}$ annotation to denote reference with obligation to release storage
        \item $\texttt{dependent}$ annotation for sharing; user ensures lifetimes contained properly % lifetime of dependent is within lifetime of owner
    \end{itemize}
  \pause
  Ownership Types \footcite{clarke_ownership_1998}
    \vspace{-0.1in}
    \begin{itemize}
      \item Each object 1) owns a context and 2) is owned by a surrounding context \note{context: nested store partition; program begins in root context}
      \item Object's definition includes \alert{unique} object context that owns it
      \item Owning an object and having a reference to it are not the same
      \item Type + context declaration = \alert{ownership type}
    \end{itemize}
  \pause
  Singularity \footcite{fahndrich_language_2006}
    \vspace{-0.1in}
    \begin{itemize}
        \item Type system tracks resources, passes ownership of arguments to callee \note{possibly permanently}
    \end{itemize}
  \vspace{0.1in}
\end{frame}
\note[itemize]{
  \item Clarke: two variables having ownership types with different declared object contexts cannot refer to same part of store, are not aliases
}

\begin{frame}[fragile]{Rust \footcite{matsakis_rust_2014}\footcite{jung_rustbelt:_2017}}
    \begin{columns}
    \begin{column}{0.46\textwidth}

    \begin{itemize}
        \item Ownership and lifetimes \note{every value has uniquer owner}
        \item Type system enforces that objects have unique \alert{owners}; functions transfer ownership \note{shallow copy, no data dupl of vec}
        \item Objects may be borrowed for no longer than owner \note{unique mutable borrows, or multiple immutable borrows, to solve aliasing}
        \item Object automatically \alert{deallocated} when owner leaves scope
    \end{itemize}

    \end{column}

    \pause

    \begin{column}{0.52\textwidth}
\begin{lstlisting}[
    language=Rust,numbers=left,mathescape,basicstyle={\scriptsize\ttfamily},
    moredelim={**[is][{\btHL<3>}]{@1}{@}},
    moredelim={**[is][{\btHL<4>}]{@2}{@}},
    moredelim={**[is][{\btHL<5>}]{@3}{@}},
    moredelim={**[is][{\btHL<6>}]{@4}{@}},
    moredelim={**[is][{\btHL<7>}]{@5}{@}},
    moredelim={**[is][{\btHL<8>}]{@6}{@}},
    moredelim={**[is][{\btHL<9>}]{@7}{@}},
    moredelim={**[is][{\btHL<10>}]{@8}{@}},
]
@1let (snd, rcv) = channel();@
@2join(move || {@
@3      let mut v = Vec::new();
@3      v.push(0);@
@4      snd.send(v);@
@8      v.push(1);@
    },
@5    move || {@
@6      let v = rcv.recv().unwrap();@
@7      println!("Received: {:?}", v);@
    });
\end{lstlisting}
\end{column}
\end{columns}

\end{frame}
\note[itemize]{
\item performing certain actions on a resource (reading and writing a memory location) should require a 'right' 
\item or capability that is uniquely owned by one alias at any point during the execution of the program.
\item although right is uniquly owned, it cn be transferred from one alias to another
\item can be shared in a controlled manner
\item note it's affine (can drop but not duplicate)
}

\begin{frame}{The Rust Conglomeration}
Rust OS \footcite{levy_ownership_2015}
    \begin{itemize}
        \item Ownership \emph{hinders} resource sharing
        \item AMM not optimized for HW resources/device drivers?
        \item Closures' req for dynamic memory is bad for embedded systems
    \end{itemize}
\todo{David's attempt}
% \item Improves on Cogent b/c recursion, iteration, borrowing, mutable state
% \item $\texttt{unsafe}$ keyword for separating worlds %(i.e. Checked C's checked regions, Cogent) % TODO mention Cogent?!
%  \item Objects may be borrowed for no longer than owner \note{like regions} \note{\alert{unique} mutable borrows, or multiple immutable borrows, to solve aliasing}
\end{frame}

\begin{frame}{Quick Temporal Recap}
    \begin{itemize}
      \item Capabilities and pointer-based metadata \note{can leverage info from spatial techniques to get full temporal safety}
      \item Regions \note{look toward effect types as an alternative to GC}
      \item Linear types \note{deallocate after use}
      \item Ownership and borrowing \note{unique owners help determine who is in charge, prevent data races, responsibility for cleaning}
    \end{itemize}
\end{frame}

\begin{frame}{Conclusion}
    \begin{itemize}[<+->]
        \item Memory errors $\equiv$ \emph{type errors}
        \item \emph{Static} memory management % like stack-based approach, important for embedded systems
        \item Be reasonable and optimistic % dynamic approaches still needed, static has come a long way
    \end{itemize}
\end{frame}

\begin{frame}{Thanks}
    \begin{center}
        \Huge{Thanks!}
    \end{center}
\end{frame}

%\subsection{Extra Slides}
%\begin{frame}{Hardware and Other Support for Spatial Safety}
%\begin{itemize}
% spin os
% \footcite:cha_retos:_2007 
%    \item \footcite{arora_architectural_2006}
%    \item \footcite{devietti_hardbound:_2008}
%    \item \footcite{binary compatible, low overhead}
%      % - can reduce overhead of CCured's SEQ and WILD pointers, array bounds checking in C#
%    \item \footcite{cowan_stackguard:_1998}
%     % - inserts canaries
%    \item \footcite{hasabnis_light-weight_2012}
%     % - guard zones with good performance
%    \footcite{kedia_simple_2017} %        -adding manual memory amangement to high-level langauges C#/java
% not sure where to include
%  \footcite:necula_proof-carrying_1997
%  \footcite:smith_sound_1998 
%  \footcite:siff_coping_1999 (physical subtyping, used by CCured)
%  seL4
%\end{itemize}
%\end{frame}

\begin{frame}{Alias Types}
  Alias types \footcite{smith_alias_2000}
    \begin{itemize}
        \item Problem: registers must be reused for data of different types constantly
        \item Aliasing constraints: describe shape of store; functions use to specify what they expect part of the store to look like
        \item Location and store polymorphism: dependence between pointer types and constraints, abstract away size/shape of store
        \item More expressive than linear: although aliasing constraints are linear, ptr values that flow through computation are not
        \item Constraint is mapping from locations to types; Pointer to location l has singleton type ptr(l)
    \end{itemize}
\end{frame}

\begin{frame}{Object-Based Temporal Safety}
\begin{itemize}
\item Mark locations which were de-allocated in shadow memory space (i.e. track a few bits of state for each byte in memory, indicating if location is currently valid)
\item Detect access of de-allocated locations
\item Fails if pointer points again to re-allocated space
\item Memcheck [30] 
    \begin{itemize}
      \item 10x slowdown
    \end{itemize}
\item Address Sanitizer: Serebryany "address santizier" 2012
    \begin{itemize}
        \item tripwire approach
        \item 73% slowdown
        \item can also detect small-stride buffer overflows
    \end{itemize}
\item Purify, valgrind
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Extended Static Checking}
Extended Static Checking (ESC) \footcite{detlefs_overview_1995}
    \begin{itemize}
      \item use automatic theorem prover to detect index bounds in Modula-3
      \item use info in annotations to assist
      \item easier than C b/c no ptr arithmetic
    \end{itemize}
Also see: ESC/Java \footcite{flanagan_extended_2002}
\end{frame}

\begin{frame}[fragile]{LCLint}
LCLint \footcite{larochelle_statically_2001}
\begin{itemize}
    \item Leverage LCLint, an annotation-assisted buffer detection tool
    \item Annotations that constrain possible values a reference contains before/after funcall
    \item Function pre/post-condition with: $\footnotesize{\texttt{requires, ensures, unique, returned, modifies, out}}$ clauses
    \item Assumptions are $\texttt{minSet, maxSet, minRead, maxRead}$ % TODO put notes of what these mean, use in example below!!!
    \item Generates constraints at expression level, resolved w/ checking at statement level
    \item Heuristics to deal with loops nicely enough; neither sound nor complete
\end{itemize}
    Also see: ETC/Modula-3 \footcite{detlefs_overview_1995}, ETC/Java \footcite{flanagan_extended_2002}, CSSV \footcite{dor_cssv:_2003}
    \vspace{0.2in}
\end{frame}

\begin{frame}[fragile]{CSSV}
CSSV \footcite{dor_cssv:_2003}
\begin{itemize}
    \item Source-to-source translation
    \item Instruments program w/ additional variables describing string attrs
    \item Adds ~assert~ statements checking for unsafe string ops
    \item Statically analyze instr. version with \emph{integer analysis} to determine possible assertion failures
    \item Handles overlapping ptrs, etc.
    \item Disadv: \# vars in instr. quadratic in \# in orig.
\end{itemize}
    Also see: ETC/Modula-3 \footcite{detlefs_overview_1995}, LCLint \footcite{larochelle_statically_2001}, ETC/Java \footcite{flanagan_extended_2002}
    \vspace{0.2in}
\end{frame}
%- fullcite:bodik_abcd:_2002 <----
%- fullcite:wagner_first_2000 
%- disadv: proves correct fraction of array/ptr references (useful for reducing checks)

% longer version of these
\begin{frame}{Other Linear Types}
  Typestate \footcite{strom_typestate:_1986}
    \begin{itemize}
        \item Avoid nonsensical execution sequences statically (using uninitialized value)
        \item Typestate is static invariant of each variable name at program point % i.e. need to merge control-paths, regardless of path to get to point
        \item Define a lattice of states and typestate transition system between them
        \item Linear types help because of restricting pointer assignment (1-1 mapping between variable names and run-time objects)
    \end{itemize}

  Quasi-linear types \footcite{kobayashi_quasi-linear_1999} % relaxtes linear type strong condition
    \begin{itemize}
        %\item Relax linear type strong condition
        \item Distinguish between consumed values vs those that may be returned
        \item Use $\kappa$ to control how often a variable of type $\tau^{\kappa}$ is used
        \item $\kappa = \delta$: accessed many times \emph{locally}, cannot be returned
%        \item Inspired $\textsc{paclang}$
%            \begin{itemize}
%                \item 0: not used at all
%                \item 1: value accessed at most once
%                \item $\omega$: accessed arbitrary number of times
%                \item $\delta$: accessed many times \emph{locally}, cannot be returned with result
%            \end{itemize}
        %\item Quasi-linear value (1) accessed as $\delta$ and then strictly as linear
        %\item Inspired PacLang
    \end{itemize}
    \vspace{0.1in}
\end{frame}

\begin{frame}{Other Linear Types}
\footnotesize
  Vault \footcite{deline_enforcing_2001} % TODO review this, TODO where is best place to put this, it combines typestate with regions like Cyclone...
    \vspace{-0.09in}
    \begin{itemize}
        \item Keys associate static capabilities with run-time resources %, held-key set, type guards
        \item Functions annotated with effect clause (pre- and post-conditions on held-key set contents)
        %\item Freed regions before leaving scope % todo review
        %\item Types enforce code must free a region % todo review
        %\item static enforcement of various protocols
        %\item Restrict aliasing, tracks fine-grained effects (requires more annotations)
        \item Windows 2000 locking errors, IRP ownership model % corresponds to tracked types
        % IRP = I/O Request Packets
        % todo add example?
    \end{itemize}
  Ordered types for memory layout \footcite{petersen_type_2003}
    \vspace{-0.09in}
    \begin{itemize}
        \item Restrict linear types (remove exchange property)
        \item Variables cannot change position $\Rightarrow$ locations in memory
        \item ``Orderly lambda calculus'' for size-preserving memory operations
        \item Coercions to manipulate ordered variables in frontier (combine/split to treat as different types)
    \end{itemize}
  \vspace{0.1in}
\end{frame}

\begin{frame}{Typestate}
  Typestate \footcite{strom_typestate:_1986}
    \begin{itemize}
        \item Avoid nonsensical execution sequences statically (using uninitialized value)
        \item Typestate is static invariant of each variable name at program point % i.e. need to merge control-paths, regardless of path to get to point
        \item Define a lattice of states and typestate transition system between them
        \item Linear types help because of restricting pointer assignment (1-1 mapping between variable names and run-time objects)
    \end{itemize}
\end{frame}

% what rust's type system is based on
\begin{frame}{Some Practical Affine Types}
  Alms \footcite{tov_practical_2011}
    \begin{itemize}
        \item Practical and general purpose
        \item Affine types: a \emph{weakening} of linear types: can drop but not duplicate
        \item Affine capabilities: separate a read-only reference to array from an affine writeable reference
        \item Define $^{a}\lambda_{ms}$ (based on System $F^{\omega}_{<:}$) and proof of soundness \note{types are maintained during evaluation, assuming no divergence}
        \item Implemented a capability-based interface to Berkeley sockets
        %TODO have they used it for memory management?
    \end{itemize}
\end{frame}

\begin{frame}{Some Cyclone Abstract Syntax}
\scriptsize{
\begin{alignat*}{2}
\text{kinds}\quad &\kappa &&::= T \altm R
\\
\text{type and region vars}\quad &\alpha,\rho &&
\\
\text{region sets}\quad &\epsilon &&::= \emptyset \altm \alpha_n \epsilon_1 \cup \epsilon_2
\\
\text{region constraints} \quad &\gamma &&::= \emptyset \altm \gamma, \epsilon <: \rho
\\
\text{constructors} \quad &\tau &&::= \alpha \altm \text{int} \altm \tau_1 \xrightarrow[]{\epsilon} \tau_2 \altm \tau_1 \times \tau_2 \altm \tau \ast \rho \altm
\\
~ & ~ && \qquad \text{handle}(\rho) \altm \forall\alpha:\kappa \triangleright \gamma.\tau \altm \exists \alpha:\kappa \triangleright \gamma.\tau
\\
\text{expressions} \quad &e &&::= x_\rho \altm v \altm e\ \langle\tau\rangle \altm (e_1,e_2) \altm e.i \altm \ast e \altm \textbf{rnew}(e_1)e_2 \altm
\\
~ & ~ && \qquad e_1(e_2) \altm \&e \altm e_1 = e_2 \altm \textbf{pack} [\tau_1, e]\textbf{ as } \tau_1
\\
\text{values} \qquad &v &&::= i \altm f \altm \&p \altm \textbf{region}(\rho) \altm (v_1, v_2) \altm \textbf{pack}[\tau_1,v]\textbf{ as } \tau_2
\\
\text{paths} \qquad &p &&::= x_\rho \altm p.i
\\
\text{functions} \qquad &f &&::= \rho:(\tau_1\ x_{\rho}) \xrightarrow[]{\epsilon} \tau_2 = \{s\} \altm \Lambda\alpha:\kappa \triangleright \gamma.f
\\
\text{statements} \qquad &s &&::= e \altm \textbf{return } e \altm s_1;s_2 \altm \textbf{if } (e)\ s_1 \textbf{ else } s_2 \altm \textbf{while } (e)\ s \altm
\\
~ & ~ && \qquad \rho:\{\tau\ x_\rho = e;\ s\} \altm \textbf{region}\langle\rho\rangle\ x_{\rho}\ s \altm \rho:\{\textbf{open}[\alpha,x_{\rho}] = e;\ s\} \altm s\ \textbf{pop}[\rho]
\end{alignat*}
    }
\end{frame}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% TeX-engine: xetex
%%% End:
