\documentclass[aspectratio=169]{beamer}
% \documentclass[aspectratio=169,handout]{beamer}

\usetheme[titleformat=regular%
,numbering=fraction% use slide numbers
]{metropolis}
\metroset{%
  progressbar=foot,%
  %background=dark,
  block=fill
}
\only<handout>{\metroset{sectionpage=none}}
\only<handout>{\usecolortheme{dove}}
\usepackage{appendixnumberbeamer} % separate appendix
\usepackage[citestyle=authortitle,sorting=none]{biblatex}
\setbeamerfont{footnote}{size=\tiny}
\addbibresource{mae.bib}

\input{macros}

\only<handout>{
  \pgfpagesuselayout{4 on 1}[letterpaper,border shrink=5mm,landscape]
}

\newtoggle{notes}
%\only<beamer>{\toggletrue{notes}}

% add notes:
\iftoggle{notes}{
  \makeatletter
  \def\beamer@framenotesbegin{% at beginning of slide
    %\gdef\beamer@noteitems{}%
    %\gdef\beamer@notes{}%
    \usebeamercolor[fg]{normal text}
  }
  \makeatother
  \setbeamertemplate{note page}[plain]
  \setbeamerfont{note page}{size=\footnotesize}
  \setbeameroption{show notes on second screen=right}
}{}

\newtoggle{labdemo}
%\toggletrue{labdemo}
\newtoggle{TODO}
\toggletrue{TODO}

\title[Major Area Exam]{Memory Safety in Systems Languages} %Techniques for
%\subtitle{Tradeoffs in Efficiency and Completeness}
%\subtitle{A Balancing Act}
\subtitle{Major Area Exam}
\date{June 11, 2018}
\author{Michael Christensen}
\institute[UCSB]{
  \normalsize
  {\large \bfseries Committee:}\\
  Ben Hardekopf (\,$\vcenter{\hbox{\includegraphics[height=1em]{chair/file.eps}}}$) \quad
  Tim Sherwood \quad
  Rich Wolski
}
\titlegraphic{\hfill\includegraphics[width=2.25cm]{ucsbseal_cmyk.pdf}}

\begin{document}
\maketitle

\metroset{numbering=none}
\begin{frame}<beamer>[noframenumbering]
  \frametitle{Outline}
  \tableofcontents
\end{frame}
\metroset{numbering=fraction}

\section{Motivation}
\begin{frame}{What is a System?}
Infrastructure software upon which applications are built
% (compilers, garbage collectors, file systems, drivers, etc.)
\\
    \vspace{0.2in}
\pause
Operating Systems
  \begin{itemize}[<+->]
      \item Purpose % i.e. they need to be able to do this
          \begin{itemize}
          \item Process abstraction
          \item Named resource management
              \begin{itemize}
                  \item Multiplex physical hardware resources
                  \item Partition and abstract \textbf{memory}
              \end{itemize}
          \end{itemize}
      \item Goals: low overhead, robustness, security
  \end{itemize}
\end{frame}

%\notes{
% isolation third item for os
% files: hide peculiarites of disks/I/O decives, abstract model of device-indepdent files
% address space: virtual memory + protection
% process: running program container (registers, files, alarms, address space, etc.)
%}

\begin{frame}{Systems Languages}
\begin{itemize}[<+->]
    \item Past systems languages: \tiny{ALGOL, PL/I, Fortran, BCPL/B, C, Mesa/Cedar, Pascal/Modula-2/Oberon, C++, ...}
    \item C: the de-facto standard
        \begin{itemize}
            \item Data structure representation control
            \item Memory management control % don't need to use stdlib either
            \item Complete mutability via pointers % define what I mean here
            \item Performant
        \end{itemize}
    \item C: the unsafe standard
        \begin{itemize}
            \item Unchecked array operations $\Rightarrow$ buffer overflows
            \item Pointers $\equiv$ arrays $\Rightarrow$ hazardous pointer arithmetic
            \item Unsafe casts $\Rightarrow$ read/write arbitrary addresses
            \item Aliasing $\Rightarrow$ dangling pointers, double frees, null dereferences
        \end{itemize}
\end{itemize}
\end{frame}

%\notes{
% possibly add OS lang was used for, date
% ALGOL: formally defined syntax
% Mesa, Cedar: rich exceptions, GC
% Pascal (1971), Modula-2 (1982), Oberon (1988) % structured programming, records, pointers, dynamic allocation, information hiding, objects
% see mae3.org, mae4.org
%}

\begin{frame}{Memory Safety}
\begin{itemize}[<+->]
    \item Memory safety error: ``Any dereference of a pointer or subscripted array reference which reads or writes storage outside of the referent'' \footcite{austin_efficient_1994}
        \begin{itemize}
            \item Spatial: outside referent's \alert{address bounds}
            \item Temporal: outside referent's \alert{lifetime}
        \end{itemize}
    \item Ideal technique is
        \begin{itemize}
            \item Efficient and expressive % (hallmarks of C)
            \item Purely static % (no runtime overhead)
            \item Precise % (not overly conservative)
            \item Automatic % (legacy code $\Rightarrow$ no source or memory layout change)
        \end{itemize}
%    \item Non-goals: secrecy, security, concurrency, type safety % but are natural consequences of safety
    \item Memory errors become \alert{type errors}, management happens at \alert{compile-time}
\end{itemize}
\end{frame}

%\notes{
% some of those goals from nagakatte 201*
% undecidability of checking certain dynamic errors
% hard to verify/prove invariants about b/c
  % casts + pointers make c essentially untyped (rondon: type system is only to help know size of bytes to read/write)
  % aliasing
% make bad hard, useful easy
%}

\AtBeginSection[]
{
  \metroset{numbering=none}
  \begin{frame}<beamer>[noframenumbering]
    \frametitle{Outline}
    \tableofcontents[currentsection]
  \end{frame}
  \metroset{numbering=fraction}
}

\only<handout>{
  \addtocounter{framenumber}{1}
}

\section{Spatial Safety}

\begin{frame}[fragile]{Definition and Example}
  \footnotesize
  \begin{columns}[T]
    \begin{column}{0.45\textwidth}
        Prevent accessing out of bounds given to object
        \\
        Some approaches:
        \begin{itemize}
            \item Dynamic \small{(fat pointers, bounds tables, objects)}
            \item Semi-static \small{(via annotations and dependent types})
        \end{itemize}
    \end{column}
    \begin{column}{0.45\textwidth}
%      \lstinputlisting[language=C,mathescape]{lst/spatial_plain.c}
       \begin{lstlisting}[language=C,numbers=left,mathescape,basicstyle={\footnotesize\ttfamily}]
int main() {
    printf("hello, world!\n");
}
$$
        \end{lstlisting}
    \end{column}
  \end{columns}
\end{frame}

\subsection{Some Dynamic Approaches}

\begin{frame}[fragile]{Fat Pointers}
  \footnotesize
A fat pointer structure is contains metadata such as base address and size along with normal value
\\
+ No cost to find metadata
\\
- Incompatible with legacy code
\todo{show example figure in memory}
\end{frame}

\begin{frame}{Fat Pointers}
SafeC \footcite{austin_efficient_1994}:
  \begin{itemize}
     \item Compile-time transform, replace all pointers and extend all pointer definitions
     \item Fields include:
          \begin{itemize}
             \item base, size, storage class (errant deallocations)
             \item Unique capability issued to an allocation
          \end{itemize}
     \item Insert array access checks before each pointer/array dereference
     \item Complete spatial safety as long as
         \begin{itemize}
            \item transparent storage management
            \item no safe pointer object attribute manipulation
         \end{itemize}
     \item 275\% space overhead, 2-6x runtime overhead, 0.35-3x code size overhead
         \begin{itemize}
            \item safe pointers aren't register allocated
            \item compiler optimizations fail with additonal checks
         \end{itemize}
  \end{itemize}
\end{frame}
\begin{frame}{Fat Pointers}
Cyclone \footcite{jim_cyclone_2002}:
  \begin{itemize}
      \item Created with intended target of TAL
      \item Distinguish array pointers from non-array poitners
          \begin{itemize}
             \item never-null pointer
             \item fat pointer
             \item static analysis to warn of uninitialized poitners
           \end{itemize}
      \item Statically validate and remove non-array fat pointers
      \item 40\% runtime overhead
      \item Uses regions + automatic memory management for temporal safety
  \end{itemize}
CCured \footcite{necula_ccured:_2002}:
  \begin{itemize}
      \item Whole-program type inference to statically optimize different pointer uses via a strong type system
        \begin{itemize}
            \item SAFE: almost no overhead, no ptr arith, array indexing, type casts
            \item SEQ: fat pointers allow arith, indexing, some casts
            \item WILD: arbitrary casts, expensive dynamic checks
        \end{itemize}
    \item insert run-time checks to handle portions where static verification insufficient
    \item 3\%-87\% runtime overhead increase
  \end{itemize}
Cuckoo \footcite{west_cuckoo:_2005}
  \begin{itemize}
      \item Store array size in memory before array dimensions's first elem
      \item Check at runtime (compile-time if possible)
      \item Type system for preventing assignment of automatic objects into longer-lifetime pointers
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Fat Pointers}
  \footnotesize
  \begin{columns}[T]
    \begin{column}{0.45\textwidth}
        Foo bar baz
    \end{column}
    \begin{column}{0.45\textwidth}
%      \lstinputlisting[language=C,mathescape]{lst/spatial_objs.c}
       \begin{lstlisting}[language=C,numbers=left,mathescape,basicstyle={\footnotesize\ttfamily}]
int main() {
    printf("hello, world!\n");
}
$$
        \end{lstlisting}
    \end{column}
  \end{columns}
\end{frame}

%% - fullcite:akritidis_baggy_2009
%% - fullcite:brunink_boundless_2011

\begin{frame}[fragile]{Separate Metadata}
Overview: avoid fat pointers by spltting bounds and base metadata
\\
\todo{show example figure in memory}
\\
MSCC \footcite{xu_efficient_2004}
    \begin{itemize}
        \item Shadow structures mirror entire original structure
        \item Checked pointers modified by external libraries must have metadata updated at the library call via wappers
        \item 1.63x overhead
    \end{itemize}
\end{frame}

\begin{frame}{Separate Metadata}
CCured (2005) \footcite{necula_ccured:_2005}
    \begin{itemize}
        \item Improve original CCured work
        \item Reduce number of WILD pointers
            \begin{itemize}
                \item use physical subtyping for handling upcasts
                \item special pointer carrying runtime-type info for downcasts
            \end{itemize}
        \item fix compat issues
            \begin{itemize}
                \item specify conversions, checking at boundaries with precompiled libraries
                \item separate metadata in mirror data structure (perf hit b/c of loss of locality
            \end{itemize}
    \end{itemize}
Softbound \footcite{nagarakatte_softbound:_2009}
    \begin{itemize}
        \item {insert runtime bounds checks, consulting disjoint metadata via table lookup}
        \item {fix disjoint shadow data structure by ...}
        \item handles arbitrary casts, sub-object overflows not covered by MSCC
    \end{itemize}
\end{frame}

\begin{frame}{Separate Metadata}
Checked C \footcite{ruef_checked_2017}
    \begin{itemize}
        \item extend C with two \emph{checked pointer types}
        \item \todo{add back in two items}
%        \item "_Ptr<T>~", a pointer for dereference only (no arith)
%        \item "~_Array_ptr<T>~" and "~_Nt_array_ptr<T>_~", supporting arith w/ bounds declarations in type (latter is ~NUL~ terminated)
        \item isolate (un)safe code with /checked code regions/ at file/func/block level; prevent unchecked pointer usage and certain casts
        \item cannot blame checked code for violation
        \item compiler confirms restrictions maintained, inserts checks (poss optim away) on ptr access
        \item tool to automatically rewrite code to use checked ptrs when possible
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Separate Metadata}
  \footnotesize
  \begin{columns}[T]
    \begin{column}{0.45\textwidth}
        Foo bar baz
    \end{column}
    \begin{column}{0.45\textwidth}
%      \lstinputlisting[language=C,mathescape]{lst/spatial_objs.c}
       \begin{lstlisting}[language=C,numbers=left,mathescape,basicstyle={\footnotesize\ttfamily}]
int main() {
    printf("hello, world!\n");
}
$$
        \end{lstlisting}
    \end{column}
  \end{columns}
\end{frame}

\subsection{Some Static Approaches}
% annotations provided by user
% don't change memory layout
% prove as much statically as possible
% use run-time checks where static checking is not sufficient

\subsubsection{Annotations}

\begin{frame}[fragile]{Extended Type Checking}
Extended Type Checking (ETC) \footcite{detlefs_overview_1995}
    \begin{itemize}
      \item use automatic theorem prover to detect index bounds in Modula-3
      \item use info in annotations to assist
      \item easier than C b/c no ptr arithmetic
    \end{itemize}
Also ETC/Java \footcite{flanagan_extended_2002}
\end{frame}

\begin{frame}[fragile]{LCLint}
LCLint \footcite{larochelle_statically_2001}
\begin{itemize}
    \item leverage LCLint, an annotation-assisted *lightweight* detection tool, to detect buffer overflows
    \item more expressive annotations that constrain possible values a reference contains before/after funcall
    \item state func pre/post-cond with ~requires~ and ~ensures~ clauses (prev. also has ~unique~, ~returned~, ~modifies~, ~out~)
    \item assumptions are ~minSet~, ~maxSet~, ~minRead~, ~maxRead~
    \item gives decent examples of use
    \item constraint grammar, LCLint generates constraints at expr level, resolved w/ checking at statement level
    \item heuristics to deal with loops nicely enough
    \item neither sound nor complete
\end{itemize}
\end{frame}

\begin{frame}[fragile]{CSSV}
CSSV \footcite{dor_cssv:_2003}
\begin{itemize}
    \item source-to-source translation
    \item instruments program w/ additional variables describing string attrs
    \item adds ~assert~ statements checking for unsafe string ops
    \item statically analyze instr. version with *integer analysis* to determine possible assertion failures
    \item handles overlapping ptrs, etc.
    \item  disadv: \# vars in instr. quadratic in \# in orig.
\end{itemize}
\end{frame}

%- fullcite:bodik_abcd:_2002 <----
%- fullcite:wagner_first_2000 
%- disadv: proves correct fraction of array/ptr references (useful for reducing checks)

\begin{frame}[fragile]{Annotations}
  \footnotesize
  \begin{columns}[T]
    \begin{column}{0.45\textwidth}
        Foo bar baz
    \end{column}
    \begin{column}{0.45\textwidth}
%      \lstinputlisting[language=C,mathescape]{lst/spatial_objs.c}
       \begin{lstlisting}[language=C,numbers=left,mathescape,basicstyle={\footnotesize\ttfamily}]
int main() {
    printf("hello, world!\n");
}
$$
        \end{lstlisting}
    \end{column}
  \end{columns}
\end{frame}

\subsubsection{Dependent Types}

\begin{frame}{Dependent Types}
    Dependent types are \emph{typed-valued functions} \footcite{pierce_advanced_2005}
    \begin{itemize}
        \item E.g. type family of vectors: $\texttt{Vector :: Nat}\rightarrow\texttt{*}$.
        \item Introduce with \emph{dependent product type}: $\texttt{vecnew : }\Pi\texttt{n:Nat.data}\rightarrow\texttt{Vector n}$.
        \item Combine as well: $\texttt{cons : }\Pi\texttt{n:Nat.data}\rightarrow\texttt{Vector n}\rightarrow\texttt{Vector(n+1)}$.
        \item Generalizes arrow type
        \item Based on type theory work by Martin-Lof \footcite{martin-lof_constructive_1984}
    \end{itemize}
\end{frame}

\begin{frame}{Dependent Types in Functional Languages}
Dependent ML \footcite{xi_eliminating_1998}
\begin{itemize}
    \item Reduce static array bound checking to constraint satisfiability
    \item Limit indices to integer and boolean expressions, constrainted to be linear
\end{itemize}
Cayenne \footcite{augustsson_cayennelanguage_1998}
\begin{itemize}
    \item Haskell-like language
    \item First time full dependent types in a PL
    \item Example typing a C-style $\texttt{printf}$ function where $\texttt{PrinftType}$ returns a type
    \item Equivalence of two arbitrary expressions is undecidable $\Rightarrow$ type checking is undecidable
\end{itemize}
\end{frame}

\begin{frame}{Dependent Types in Imperative Languages}
    $\text{Xanadu}_{0}^{\Pi,\Sigma}$ \footcite{xi_imperative_2000}
% TODO maybe use this grammar for introduction instead of condit?
\begin{itemize}
    \item Restrict type index expressions to integer constraint domain
    \item Define what it means for a type to equal/coerce into another
    \item Programmer must supply state stype in order to type conditionals and loops
    \item \todo{maybe add an example since I have room...}
\end{itemize}
\end{frame}
% \item Allows trusted cast mechanism to supress errors

\begin{frame}{Dependent Types in Imperative Languages}
SafeDrive \footcite{zhou_safedrive:_2006} and Deputy \footcite{condit_dependent_2007}
    \begin{itemize}
        \item User-added annotations relating pointers to bounds
        \item Expressions in types limited to local variables, constants, and arithmetic expr
        \item Three phase pass over annotated C programs, emits C code
            \begin{itemize}
                \item Automatic bound variables addition
                \item Flow-insensitive type checking (insert run-time checks)
                \item Flow-sensitive check optimization
            \end{itemize}
    \end{itemize}
\vspace{-0.3in}

% here I need to exaplin what a grammer is for them
\footnotesize{
\begin{gather*}
    x,y \in \text{Variables}
    \quad
    \text{op} \in \text{Binary ops}
    \quad
    n \in \text{Integers}
    \quad
    \text{comp} \in \text{Comparison Ops}
\end{gather*}

\vspace{-0.3in}

\begin{columns}[T]
\begin{column}{0.45\textwidth}
\begin{alignat*}{2}
\text{Ctors}\quad &C &&::= \text{int} \altm \text{ref} \altm ...
\\
\text{Types}\quad &\tau &&::= C \altm \tau_1 \ \tau_2 \altm \tau\ e
\\
\text{Kinds}\quad & \kappa &&::= \text{type} \altm \text{type} \rightarrow \kappa \altm \tau \rightarrow \kappa
\\
\text{L-exprs} \quad &l &&::= x \altm *e
\end{alignat*}
\end{column}

\begin{column}{0.45\textwidth}
\begin{alignat*}{2}
\textit{Exprs}\quad &e &&::= n \altm l \altm e_1 \text{ op } e_2
\\
\textit{Cmds}\quad &c &&::= \text{skip} \altm c_1;c_2 \altm l := e \altm \text{assert}(\gamma) \altm
\\
~ & ~ && \text{let } x : \tau = e \text { in } c \altm \text{let } x = \text{new } \tau(e) \text{ in } c
\\
\text{Preds}\quad &\gamma &&::= e_1 \text{ comp } e_2 \altm \text{true} \altm \gamma_1 \wedge \gamma_2
\end{alignat*}
\end{column}
\end{columns}
}

\vspace{0.1in}

\end{frame}
%\note{
% kind of int is "type"
% kind of ref is "type -> type"
% loops, conditionals omitted for flow-insenstivei type system
% Types restricted to only contain expressions using constatns, local variables, arbitrary arithmetic operators
%}


\begin{frame}{Deputy}
Judgments for checking the well-formedness of types, local expressions, predicated expressions, and commands (which add assertions)

\begin{center}
\begin{tabular}{c}
\infer[(\textsc{var\ write})]
{\Gamma \vdash x \coloneqq e \Rightarrow \text{assert}(\bigwedge_{y \in \text{Dom}(\Gamma)}\gamma_y);\ x \coloneqq e }
{x \in \text{Dom}(\Gamma) \qquad
 \text{for\ all}(y:\tau_y) \in \Gamma,\ \Gamma \vdash y[e/x]:\tau_y[e/x] \Rightarrow \gamma_y }
\end{tabular}

\begin{tabular}{c}
\infer[(\textsc{array\ deref})]
{\Gamma \vdash *e; \tau \Rightarrow \gamma_e \wedge (0 < e_{len})}
{\Gamma \vdash e: \text{array } \tau \ e_{len} \Rightarrow \gamma_e}
\end{tabular}

\begin{tabular}{c}
\infer[(\textsc{array\ arith})]
{\Gamma \vdash e + e': \text{array } \tau\ (e_{len} - e') \Rightarrow \gamma_e \wedge \gamma_e' \wedge (0 \leq e' \leq e_{len})}
    {\Gamma \vdash e: \text{array } \tau\ e_{len} \Rightarrow \gamma_e
    \quad \Gamma \vdash e':\text{int} \Rightarrow \gamma_{e'}}
\end{tabular} 
\end{center}

\end{frame}
% var-write is a key contribution of type system
% $\textsc{var\ write}$ rule responsible for updates to variables in presence of dependent type variables, verifying assignment does not break any dependencies in current scope
% For example, we can add rules for arrays:
% also permits a coercion judgement for allowing an array to be used where a smaller one is expected

\begin{frame}{Deputy}
Support in C
    \begin{itemize}
        \item Generalize array constructor to possibly-null bounded pointer $\text{ptr }\tau \ lo\ hi$
            \begin{itemize}
                \item C-style pointer arithmetic via $\oplus$ operator
                \item $x:\text{ptr int } b (b \oplus 8)$ // 8 integer area starting at b
                \item $x:\text{ptr int } x (x \oplus n)$ // n integer area starting at x
                \item $x:\text{ptr int }$ x e // from x to e
            \end{itemize}
        \item Dependent untion tags
            \begin{itemize}
                \item Leverage C idiom of providing ``tag'' indicating which union field is in use
                \item Specify the condition for each union field to be usable
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{Deputy}
\begin{columns}[T]
\begin{column}{0.45\textwidth}
      \lstinputlisting[language=C,mathescape]{lst/deputy_before.c}
\end{column}
\begin{column}{0.45\textwidth}
      \lstinputlisting[language=C,mathescape]{lst/deputy_after.c}
\end{column}
\end{columns}
\end{frame}

\begin{frame}{Dependent Types in Imperative Languages}
Low-Level Liquid Types \footcite{rondon_liquid_2008}, \footcite{rondon_low-level_2010}
\begin{itemize}
    \item Refinement types where predicates are conjunctions over qualifiers
    \item Functions qualified over locations they operate on
    \item Deal with collections using \emph{location folding} for checking out a copy to do strong updates on
\end{itemize}
Tyr \footcite{de_araujo_tyr:_2016}
\begin{itemize}
    \item Augments LLVM IR with dependent point tyeps
    \item First pass uses programmer annotations to augment program witn run-time bounds checking
    \item LLVM optimizations remove checks always true/false
\end{itemize}
\end{frame}

\begin{frame}{A Hybrid Approach}
Low* \footcite{footcite:protzenko_verified_2017}
\begin{itemize}
    \item DSL for verified, efficient low-level programming in F* (ML-like language with dependent types)
    \item Goal: write efficient \& verified C in a high-level language
    \item Write F* syntax against library modelling lower-level view of C memory
    \item Model arrays by implementation abstract buffer type using references by hyper-stacks
    \item Translate Low* to CompCert Clight
\end{itemize}
\end{frame}

\subsection{In Review}

%\begin{frame}{An Overview of Spatial Safety Approaches}
%Several deficiencies
%\begin{itemize}
%  \item High runtime overhead
%  \item Incomplete detection of spatial violations
%  \item Incompatible pointer representations (changing memory layout)
%  \item  Non-trivial changes to source code
%  \item Whole program analyses (for low-overhead) [e.g. Dhurjati 2006, Necula 2005]
%  \item Some of these aren't complete or sound
%  \item  Completely detecting buffer overflow (i.e. bounds) in general is undecidable!
%\end{itemize}
%\end{frame}


\section{Temporal Safety}

\begin{frame}[fragile]{Definition and Example}
  \footnotesize
  \begin{columns}[T]
    \begin{column}{0.45\textwidth}
        Prevent accessing object that has been previously deallocated
        \\
        Some approaches:
        \begin{itemize}
            \item Effects and regions
            \item Unique pointers and linear types
            \item Ownership and borrowing
        \end{itemize}
    \end{column}
    \begin{column}{0.45\textwidth}
%      \lstinputlisting[language=C,mathescape]{lst/spatial_plain.c}
       \begin{lstlisting}[language=C,numbers=left,mathescape,basicstyle={\footnotesize\ttfamily}]
int main() {
    printf("hello, world!\n");
}
$$
        \end{lstlisting}
    \end{column}
  \end{columns}
\end{frame}

\subsection{Dynamic Approaches}
\begin{frame}{A Comment on Garbage Collection}
    \footcite{boehm_garbage_1988}
    used by ccured (Free is a noop, no double-free, no danlging pointers, heapify escaping objects)
\end{frame}
\begin{frame}{Other Dynamic Approaches}
    \footcite{austin_efficient_1994}
    \footcite{west_cuckoo:_2005}
    % others from Other/(also from section)
\end{frame}

\subsection{Semi-Static Approaches}

\subsection{Extra Slides}
\begin{frame}{Hardware and Other Support for Spatial Safety}
\begin{itemize}
    \item \footcite{arora_architectural_2006}
    \item \footcite{devietti_hardbound:_2008}
    \item \footcite{binary compatible, low overhead}
      % - can reduce overhead of CCured's SEQ and WILD pointers, array bounds checking in C#
    \item \footcite{cowan_stackguard:_1998}
     % - inserts canaries
    \item \footcite{hasabnis_light-weight_2012}
     % - guard zones with good performance
\end{itemize}
\end{frame}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% TeX-engine: xetex
%%% End:
