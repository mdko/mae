\documentclass[aspectratio=169]{beamer}
% \documentclass[aspectratio=169,handout]{beamer}

\usetheme[titleformat=regular%
,numbering=fraction% use slide numbers
]{metropolis}
\metroset{%
  progressbar=foot,%
  %background=dark,
  block=fill
}
\only<handout>{\metroset{sectionpage=none}}
\only<handout>{\usecolortheme{dove}}
\usepackage{appendixnumberbeamer} % separate appendix
\usepackage[citestyle=authortitle,sorting=none]{biblatex}
\setbeamerfont{footnote}{size=\tiny}
\addbibresource{mae.bib}

\input{macros}

\only<handout>{
  \pgfpagesuselayout{4 on 1}[letterpaper,border shrink=5mm,landscape]
}

\newtoggle{notes}
%\only<beamer>{\toggletrue{notes}}

% add notes:
\iftoggle{notes}{
  \makeatletter
  \def\beamer@framenotesbegin{% at beginning of slide
    %\gdef\beamer@noteitems{}%
    %\gdef\beamer@notes{}%
    \usebeamercolor[fg]{normal text}
  }
  \makeatother
  \setbeamertemplate{note page}[plain]
  \setbeamerfont{note page}{size=\footnotesize}
  \setbeameroption{show notes on second screen=right}
}{}

\newtoggle{labdemo}
%\toggletrue{labdemo}
\newtoggle{TODO}
\toggletrue{TODO}

\title[Major Area Exam]{Memory Safety in Systems Languages} %Techniques for
%\subtitle{Tradeoffs in Efficiency and Completeness}
%\subtitle{A Balancing Act}
\subtitle{Major Area Exam}
\date{June 11, 2018}
\author{Michael Christensen}
\institute[UCSB]{
  \normalsize
  {\large \bfseries Committee:}\\
  Ben Hardekopf (\,$\vcenter{\hbox{\includegraphics[height=1em]{chair/file.eps}}}$) \quad
  Tim Sherwood \quad
  Rich Wolski
}
\titlegraphic{\hfill\includegraphics[width=2.25cm]{ucsbseal_cmyk.pdf}}

\begin{document}
\maketitle

\metroset{numbering=none}
\begin{frame}<beamer>[noframenumbering]
  \frametitle{Outline}
  \tableofcontents
\end{frame}
\metroset{numbering=fraction}

\section{Motivation}
\begin{frame}{What is a System?}
Infrastructure software upon which applications are built
% (compilers, garbage collectors, file systems, drivers, etc.)
\\
    \vspace{0.2in}
\pause
Operating Systems
  \begin{itemize}[<+->]
          % need to be able to do this
    \item Process abstraction
    \item Named resource management
       \begin{itemize}
           \item Multiplex physical hardware resources
           \item Partition and abstract \textbf{memory}
       \end{itemize}
    \item Low overhead, robustness, security
  \end{itemize}
\end{frame}

%\notes{
% isolation third item for os
% files: hide peculiarites of disks/I/O decives, abstract model of device-indepdent files
% address space: virtual memory + protection
% process: running program container (registers, files, alarms, address space, etc.)
%}

\begin{frame}{Systems Languages}
\begin{itemize}[<+->]
    \item Past systems languages: \tiny{ALGOL, PL/I, Fortran, BCPL/B, C, Mesa/Cedar, Pascal/Modula-2/Oberon, C++, ...}
    \item C: the de-facto standard
        \begin{itemize}
            \item Data structure representation control
            \item Memory management control % don't need to use stdlib either
            \item Complete mutability via pointers % define what I mean here
            \item Performant
        \end{itemize}
    \item C: the unsafe standard
        \begin{itemize}
            \item Unchecked array operations $\Rightarrow$ buffer overflows
            \item Pointers $\equiv$ arrays $\Rightarrow$ hazardous pointer arithmetic
            \item Unsafe casts $\Rightarrow$ read/write arbitrary addresses
            \item Aliasing $\Rightarrow$ dangling pointers, double frees, null dereferences
        \end{itemize}
\end{itemize}
\end{frame}

%\notes{
% possibly add OS lang was used for, date
% ALGOL: formally defined syntax
% Mesa, Cedar: rich exceptions, GC
% Pascal (1971), Modula-2 (1982), Oberon (1988) % structured programming, records, pointers, dynamic allocation, information hiding, objects
% see mae3.org, mae4.org
%}

\begin{frame}{Memory Safety}
\begin{itemize}[<+->]
    \item Memory safety error: ``Any dereference of a pointer or subscripted array reference which reads or writes storage outside of the referent'' \footcite{austin_efficient_1994}
        \begin{itemize}
            \item Spatial: outside referent's \alert{address bounds}
            \item Temporal: outside referent's \alert{lifetime}
        \end{itemize}
    \item Ideal technique is
        \begin{itemize}
            \item Efficient and expressive % (hallmarks of C)
            \item Purely static % (no runtime overhead)
            \item Precise % (not overly conservative)
            \item Automatic % (legacy code $\Rightarrow$ no source or memory layout change)
        \end{itemize}
%    \item Non-goals: secrecy, security, concurrency, type safety % but are natural consequences of safety
    \item Memory errors become \alert{type errors}, management happens at \alert{compile-time}
\end{itemize}
\end{frame}

%\notes{
% some of those goals from nagakatte 201*
% undecidability of checking certain dynamic errors
% hard to verify/prove invariants about b/c
  % casts + pointers make c essentially untyped (rondon: type system is only to help know size of bytes to read/write)
  % aliasing
% make bad hard, useful easy
%}

\AtBeginSection[]
{
  \metroset{numbering=none}
  \begin{frame}<beamer>[noframenumbering]
    \frametitle{Outline}
    \tableofcontents[currentsection]
  \end{frame}
  \metroset{numbering=fraction}
}

\only<handout>{
  \addtocounter{framenumber}{1}
}

\section{Spatial Safety}

\begin{frame}[fragile]{Spatial Safety}
  \footnotesize
  \begin{columns}[T]
    \begin{column}{0.45\textwidth}
        Prevent accessing out of object's bounds
        \\
        Some approaches:
        \begin{itemize}
            \item Dynamic \footnotesize{(fat pointers, bounds tables, objects)}
            \item Semi-static \footnotesize{(constraint checking via annotations and dependent types})
        \end{itemize}
    \end{column}
    \begin{column}{0.45\textwidth}
\begin{lstlisting}[language=C,mathescape] %,basicstyle={\footnotesize\ttfamily}]

int sum(int *buf, int *end) {
    int sum = 0;
    while(buf < end) {
        sum += *buf;
        int *tmp = buf + 1;
        buf = tmp;
    }
    return sum;
}
\end{lstlisting}
Let's list the potential problems:
        \begin{itemize}
            \item $\texttt{buf}$ or $\texttt{end}$ could be null
            \item $\texttt{buf}$ and $\texttt{end}$ could be entirely unrelated
            \item $\texttt{buf}$ might not be an array % e.g. pointer to struct? problem with casting
        \end{itemize}
    \end{column}
  \end{columns}
\end{frame}

\subsection{Some Dynamic Approaches}

\begin{frame}[fragile]{Fat Pointers}
  \footnotesize
Fat pointers
\begin{itemize}
 \item Contains metadata such as base address and bounds along with value
 \item Safe and quick to retrieve find metadata
 \item Incompatibility with uninstrumented libaries, run-time overhead, bloated code size
 \item Automatic run-time check insertion to overcome static detection weakness
 \item Approximately 3\% - 200\% runtime overhead versus plain
\end{itemize}
\end{frame}

\begin{frame}{Fat Pointers}
SafeC \footcite{austin_efficient_1994}:
  \begin{itemize}
     \item Compile-time transform, replace all pointers and extend all pointer definitions
     \item Fields include:
          \begin{itemize}
             \item base, size, storage class (errant deallocations)
             \item Unique capability issued to an allocation
          \end{itemize}
     \item Insert array access checks before each pointer/array dereference
     \item Complete spatial safety as long as
         \begin{itemize}
            \item transparent storage management
            \item no safe pointer object attribute manipulation
         \end{itemize}
     \item 275\% space overhead, 2-6x runtime overhead, 0.35-3x code size overhead
         \begin{itemize}
            \item safe pointers aren't register allocated
            \item compiler optimizations fail with additonal checks
         \end{itemize}
  \end{itemize}
\vspace{0.2in}
\end{frame}

\begin{frame}{Fat Pointers}
\footnotesize
CCured \footcite{necula_ccured:_2002}:
      \begin{itemize}
          \item Strong type system helps inference statically optimize different pointer uses % whole program type inference
          \item $\texttt{SAFE}$: almost no overhead, no ptr arith, array indexing, type casts
          \item $\texttt{SEQ}$: fat pointers allow arith, indexing, some casts
          \item $\texttt{WILD}$: arbitrary casts, expensive dynamic checks
%          \item Very detailed description of run-time checks generated and translation for each expression
          \item Relies on a garbage collector
          %\item 3\%-87\% runtime overhead increase
      \end{itemize}

Cyclone \footcite{jim_cyclone:_2002}: % offshoot of TAL/popcorn
      \begin{itemize}
          \item Array vs non-array pointers (never-null, fat, unitialized warning via control-flow analysis)
          \item Tagged unions and automatic tag injection (e.g. $\texttt{printf}$)
          %\item Statically validate and remove non-array fat pointers
          \item Arrays and strings converted automatically to fat
          %\item 40\% runtime overhead
          %\item Uses regions + automatic memory management for temporal safety (free is a no-op) (see nice example)
          %\item never null don't need checks, use @; push back null checks from uses to their sources
          %\item ? permits pointer arithmetic
          %\item Restrict arithmetic on regular pointers
      \end{itemize}
\vspace{0.2in}
\end{frame}

\begin{frame}{Fat Pointers}
Cuckoo \footcite{west_cuckoo:_2005}
      \begin{itemize}
          \item Store array size in memory before array dimensions's first element
          \item Name of an array is pointer to an \emph{array}, not first object
          \item Type system for preventing assignment of automatic objects into longer-lifetime pointers
          \item Wrap dynamic memory allocation (type homogeneous pool-based) % will explain later
          \item Forbid addition and subtraction expressions including pointer operands! % statically determining given pointer points to an array object is undecidable
        % compile-time checks if array bounds are constants, otherwise run-time checks
      \end{itemize}

\end{frame}

\begin{frame}[fragile]{Fat Pointers}
  \footnotesize
  \begin{columns}[T]
    \begin{column}{0.45\textwidth}
    $\vcenter{\hbox{\includegraphics[height=8em]{fig/FIGURE_necula-2005_ccured-seq.PNG}}}$
    \end{column}
    \begin{column}{0.45\textwidth}
\begin{lstlisting}[language=C,mathescape] %,basicstyle={\footnotesize\ttfamily}]

int sum(int *SEQ buf, int *SEQ end) {
    int sum = 0;
    while(buf < end) {
        assert(buf.b $\leq$ buf.p $\leq$ buf.e - sizeof(int));
        sum += *(buf.p);
        buf.p = buf.p + (1 * sizeof(int));
        buf.b = buf.b;
        buf.e = buf.e;
    }
    return sum;
}
\end{lstlisting}
    \end{column}
  \end{columns}
\end{frame}

%% - fullcite:akritidis_baggy_2009
%% - fullcite:brunink_boundless_2011

\begin{frame}[fragile]{Separate Metadata}
Overview: avoid fat pointers by spltting bounds and base metadata
\\
\todo{show example figure in memory}
\\
MSCC \footcite{xu_efficient_2004}
    \begin{itemize}
        \item Shadow structures mirror entire original structure
        \item Checked pointers modified by external libraries must have metadata updated at the library call via wappers
        \item 1.63x overhead
    \end{itemize}
\end{frame}

\begin{frame}{Separate Metadata}
CCured (2005) \footcite{necula_ccured:_2005}
    \begin{itemize}
        \item Improve original CCured work
        \item Reduce number of WILD pointers
            \begin{itemize}
                \item use physical subtyping for handling upcasts
                \item special pointer carrying runtime-type info for downcasts
            \end{itemize}
        \item Fix compatiblity issues
            \begin{itemize}
                \item specify conversions, checking at boundaries with precompiled libraries
                \item separate metadata in mirror data structure (perf hit b/c of loss of locality
            \end{itemize}
    \end{itemize}
Softbound \footcite{nagarakatte_softbound:_2009}
    \begin{itemize}
        \item Insert runtime bounds checks, consulting disjoint metadata via table lookup
%        \item \todo{fix disjoint shadow data structure by ...}
        \item Handles arbitrary casts, sub-object overflows not covered by MSCC
        \item Transforms every function declaration and call-site to pass additional base and bound arguments % for metadata propagation
    \end{itemize}
\end{frame}

\begin{frame}{Separate Metadata}
Checked C \footcite{ruef_checked_2017}
    \begin{itemize}
        \item Extend C with two \emph{checked pointer types}, automatically rewrite code to use when possible
        \item Derefence-only (no arith.) pointer, Arithmetic-supporting (possibly null-terminated) pointer with bounds in type
%        \item $\verb{_Ptr<T>}$, a pointer for dereference only (no arith)
%        \item $\verb{_Array_ptr<T>}$ and $\verb{_Nt_array_ptr<T>_}$, supporting arith w/ bounds declarations in type (latter is null-terminated)
        \item Isolate (un)safe code with \emph{checked code regions} at file/func/block level; prevent unchecked pointer usage and certain casts
        \item Cannot blame checked code for violation
%       \item Compiler confirms restrictions maintained, inserts checks on ptr access
    \end{itemize}
\end{frame}


\begin{frame}[fragile]{Separate Metadata}
  \footnotesize
  \begin{lstlisting}[language=C,numbers=left,mathescape,basicstyle={\footnotesize\ttfamily}]
int sum(int *buf, int *end) {
    int sum = 0;
    $\colorbox{red!30}{int bufbase = table\_lookup(buf)->base;}$
    $\colorbox{red!30}{int bufbound = table\_lookup(buf)->bound;}$
    while(buf < end) {
        $\colorbox{red!30}{if ((buf < bufbase) || ((buf + sizeof(buf)) > bufbound)) abort;}$
        sum += *buf;
        int *tmp = buf + 1;
        $\colorbox{red!30}{int tmpbase = bufbase; int tmpbound = bufbound;}$ // inherit base and bound of original ptr
        $\colorbox{red!30}{int bufbase = tmpbase; int bufbound = tmpbound;}$ // would be optimized out
        buf = tmp;
    }
    return sum;
}
  \end{lstlisting}
\end{frame}
% question: where is table stored (heap or stack?)

\subsection{Some Static Approaches}
% annotations provided by user
% don't change memory layout
% prove as much statically as possible
% use run-time checks where static checking is not sufficient

\subsubsection{Annotations}

\begin{frame}[fragile]{Extended Type Checking}
\todo{Maybe get rid of this whole section}
Extended Type Checking (ETC) \footcite{detlefs_overview_1995}
    \begin{itemize}
      \item use automatic theorem prover to detect index bounds in Modula-3
      \item use info in annotations to assist
      \item easier than C b/c no ptr arithmetic
    \end{itemize}
Also ETC/Java \footcite{flanagan_extended_2002}
\end{frame}

\begin{frame}[fragile]{LCLint}
LCLint \footcite{larochelle_statically_2001}
\begin{itemize}
    \item leverage LCLint, an annotation-assisted *lightweight* detection tool, to detect buffer overflows
    \item more expressive annotations that constrain possible values a reference contains before/after funcall
    \item state func pre/post-cond with ~requires~ and ~ensures~ clauses (prev. also has ~unique~, ~returned~, ~modifies~, ~out~)
    \item assumptions are ~minSet~, ~maxSet~, ~minRead~, ~maxRead~
    \item gives decent examples of use
    \item constraint grammar, LCLint generates constraints at expr level, resolved w/ checking at statement level
    \item heuristics to deal with loops nicely enough
    \item neither sound nor complete
\end{itemize}
\end{frame}

\begin{frame}[fragile]{CSSV}
CSSV \footcite{dor_cssv:_2003}
\begin{itemize}
    \item source-to-source translation
    \item instruments program w/ additional variables describing string attrs
    \item adds ~assert~ statements checking for unsafe string ops
    \item statically analyze instr. version with *integer analysis* to determine possible assertion failures
    \item handles overlapping ptrs, etc.
    \item  disadv: \# vars in instr. quadratic in \# in orig.
\end{itemize}
\end{frame}

%- fullcite:bodik_abcd:_2002 <----
%- fullcite:wagner_first_2000 
%- disadv: proves correct fraction of array/ptr references (useful for reducing checks)

\begin{frame}[fragile]{Annotations}
  \footnotesize
  \begin{columns}[T]
    \begin{column}{0.45\textwidth}
        Foo bar baz
    \end{column}
    \begin{column}{0.45\textwidth}
%      \lstinputlisting[language=C,mathescape]{lst/spatial_objs.c}
       \begin{lstlisting}[language=C,numbers=left,mathescape,basicstyle={\footnotesize\ttfamily}]
int main() {
    printf("hello, world!\n");
}
$$
        \end{lstlisting}
    \end{column}
  \end{columns}
\end{frame}

\subsubsection{Dependent Types}

\begin{frame}{Dependent Types}
    Dependent types are \emph{typed-valued functions} \footcite{pierce_advanced_2005}
    \begin{itemize}
        \item E.g. type family of vectors: $\texttt{Vector :: Nat}\rightarrow\texttt{*}$.
        \item Introduce with \emph{dependent product type}: $\texttt{vecnew : }\Pi\texttt{n:Nat.data}\rightarrow\texttt{Vector n}$.
        \item Combine as well: $\texttt{cons : }\Pi\texttt{n:Nat.data}\rightarrow\texttt{Vector n}\rightarrow\texttt{Vector(n+1)}$.
        \item Generalizes arrow type
        \item Based on type theory work by Martin-Lof \footcite{martin-lof_constructive_1984}
    \end{itemize}
\end{frame}

\begin{frame}{Dependent Types in Functional Languages}
Dependent ML \footcite{xi_eliminating_1998}
\begin{itemize}
    \item Reduce static array bound checking to constraint satisfiability
    \item Limit indices to integer and boolean expressions, constrained to be linear and compile-time decidable
\end{itemize}
Cayenne (Haskell-like) \footcite{augustsson_cayennelanguage_1998}
\begin{itemize}
    \item First time \emph{full dependent} types in a PL
    \item No restriction on expressions in types
    %\item Example typing a C-style $\texttt{printf}$ function where $\texttt{PrinftType}$ returns a type
    \item Undecidability of arbitrary expression equivalence and thus type checking
\end{itemize}
$\text{Xanadu}_{0}^{\Pi,\Sigma}$ (C-like) \footcite{xi_imperative_2000}
\begin{itemize}
    \item Like DML, restrict index expressions in types to integer constraint domain
    \item Defines what it means for a type to equal/coerce into another
    \item Programmer must supply state type in order to type conditionals and loops
\end{itemize}
\end{frame}

% \item Allows trusted cast mechanism to supress errors

\begin{frame}{Dependent Types in Imperative Languages}
SafeDrive \footcite{zhou_safedrive:_2006} and Deputy \footcite{condit_dependent_2007}
    \begin{itemize}
        \item User-added annotations relating pointers to bounds
        \item Expressions in types limited to local variables, constants, and arithmetic expr
        \item Three phase pass over annotated C programs, emits C code
            \begin{itemize}
                \item Automatic bound variables addition
                \item Flow-insensitive type checking (insert run-time checks)
                \item Flow-sensitive check optimization
            \end{itemize}
    \end{itemize}
\vspace{-0.3in}

% here I need to exaplin what a grammer is for them
\footnotesize{
\begin{gather*}
    x,y \in \text{Variables}
    \quad
    \text{op} \in \text{Binary ops}
    \quad
    n \in \text{Integers}
    \quad
    \text{comp} \in \text{Comparison Ops}
\end{gather*}

\vspace{-0.3in}

\begin{columns}[T]
\begin{column}{0.45\textwidth}
\begin{alignat*}{2}
\text{Ctors}\quad &C &&::= \text{int} \altm \text{ref} \altm ...
\\
\text{Types}\quad &\tau &&::= C \altm \tau_1 \ \tau_2 \altm \tau\ e
\\
\text{Kinds}\quad & \kappa &&::= \text{type} \altm \text{type} \rightarrow \kappa \altm \tau \rightarrow \kappa
\\
\text{L-exprs} \quad &l &&::= x \altm *e
\end{alignat*}
\end{column}

\begin{column}{0.45\textwidth}
\begin{alignat*}{2}
\textit{Exprs}\quad &e &&::= n \altm l \altm e_1 \text{ op } e_2
\\
\textit{Cmds}\quad &c &&::= \text{skip} \altm c_1;c_2 \altm l := e \altm \text{assert}(\gamma) \altm
\\
~ & ~ && \text{let } x : \tau = e \text { in } c \altm \text{let } x = \text{new } \tau(e) \text{ in } c
\\
\text{Preds}\quad &\gamma &&::= e_1 \text{ comp } e_2 \altm \text{true} \altm \gamma_1 \wedge \gamma_2
\end{alignat*}
\end{column}
\end{columns}
}

\vspace{0.1in}

\end{frame}
%\note{
% kind of int is "type"
% kind of ref is "type -> type"
% loops, conditionals omitted for flow-insenstivei type system
% Types restricted to only contain expressions using constatns, local variables, arbitrary arithmetic operators
% Type environment is a predicate on the state of the program
%}

\begin{frame}{Deputy}
Judgments for checking the well-formedness of types, local expressions, predicated expressions, and commands

\pause

\begin{center}
\begin{tabular}{c}
\infer[(\textsc{var\ write})]
{\Gamma \vdash x \coloneqq e \Rightarrow \text{assert}(\bigwedge_{y \in \text{Dom}(\Gamma)}\gamma_y);\ x \coloneqq e }
{x \in \text{Dom}(\Gamma) \qquad
 \text{for\ all}(y:\tau_y) \in \Gamma,\ \Gamma \vdash y[e/x]:\tau_y[e/x] \Rightarrow \gamma_y }
\end{tabular}

\pause

\begin{tabular}{c}
\infer[(\textsc{array\ deref})]
{\Gamma \vdash *e; \tau \Rightarrow \gamma_e \wedge (0 < e_{len})}
{\Gamma \vdash e: \text{array } \tau \ e_{len} \Rightarrow \gamma_e}
\end{tabular}

\pause

\begin{tabular}{c}
\infer[(\textsc{array\ arith})]
{\Gamma \vdash e + e': \text{array } \tau\ (e_{len} - e') \Rightarrow \gamma_e \wedge \gamma_e' \wedge (0 \leq e' \leq e_{len})}
    {\Gamma \vdash e: \text{array } \tau\ e_{len} \Rightarrow \gamma_e
    \quad \Gamma \vdash e':\text{int} \Rightarrow \gamma_{e'}}
\end{tabular} 
\end{center}

\end{frame}
% var-write is a key contribution of type system
% $\textsc{var\ write}$ rule responsible for updates to variables in presence of dependent type variables, verifying assignment does not break any dependencies in current scope
% For example, we can add rules for arrays:
% also permits a coercion judgement for allowing an array to be used where a smaller one is expected

\begin{frame}
    \todo{describe how they use assertions afterwards}
\end{frame}

\begin{frame}{Deputy}
Support in C
    \begin{itemize}
        \item Generalize array constructor to possibly-null bounded pointer: \emph{$\text{ptr }\tau \ lo\ hi$}
            \begin{itemize}
                \item C-style pointer arithmetic via $\oplus$ operator
                \item $x:\text{ptr int } b\ (b \oplus 8)$ $\texttt{// 8 integer area starting at b}$
                \item $x:\text{ptr int } x\ (x \oplus n)$ $\texttt{// n integer area starting at x}$
                \item $x:\text{ptr int } x\ e\ \ \ \ \ \ \ \ $ $\texttt{// from x to e}$
            \end{itemize}
        \item Dependent untion tags
            \begin{itemize}
                \item Leverage C idiom: ``tag'' indicates union field in use
                \item Specify the condition for each union field to be usable
                \item \emph{$\text{union}_n\ \tau_1\ ...\ \tau_n\ e_1\ ...\ e_n$}
                \item $x:\text{struct }\{ tag:\text{int}\;\ u: \text{union}_2 \text{ int (ref int)} \ (\textit{tag} \geq 2)\ (\textit{tag} = 1) \}$
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Deputy}
\begin{columns}[T]
\begin{column}{0.45\textwidth}
\begin{lstlisting}[language=C,mathescape] %,basicstyle={\footnotesize\ttfamily}]

int sum(int *  $\colorbox{green!30}{count(end - buf)}$ buf, int * end) {
    int sum = 0;
    while(buf < end) {
        sum += *buf;
        int *tmp = buf + 1;
        buf = tmp;
    }
    return sum;
}
\end{lstlisting}
\end{column}

\begin{column}{0.45\textwidth}
%      \lstinputlisting[language=C,mathescape]{lst/deputy_after.c}
\begin{lstlisting}[language=C,mathescape] %,basicstyle={\footnotesize\ttfamily}]

int sum(int *  $\colorbox{green!30}{count(end - buf)}$ buf, int * end) {
    int sum = 0;
    while(buf < end) {
        $\colorbox{red!30}{assert(0 < end - buf);}$
        sum += *buf;
        $\colorbox{blue!30}{int tmplen = (end - buf) - 1;}$
        $\colorbox{red!30}{assert(0 <= 1 <= end - buf);}$
        int * $\colorbox{blue!30}{count(tmplen)}$ tmp = buf + 1;
        $\colorbox{red!30}{(0 <= end - tmp <= tmplen);}$
        buf = tmp;
    }
    return sum;
}
\end{lstlisting}
\end{column}
\end{columns}
    \tiny{$\colorbox{green!30}{Programmer-supplied annotation}$}
    \\
    \tiny{$\colorbox{blue!30}{Code added during automatic dependency inference}$}
    \\
    \tiny{$\colorbox{red!30}{Assertions added during checking}$}
\end{frame}
% All checks here would be eliminated.

\begin{frame}{Dependent Types in Imperative Languages}
Low-Level Liquid Types \footcite{rondon_liquid_2008}, \footcite{rondon_low-level_2010}
\begin{itemize}
    \item Refinement types where predicates are conjunctions over qualifiers
    \item Functions qualified over locations they operate on
    \item Deal with collections using \emph{location folding} for checking out a copy to do strong updates on
\end{itemize}
Tyr \footcite{de_araujo_tyr:_2016}
\begin{itemize}
    \item Augments LLVM IR with dependent pointer types
    \item Uses programmer annotations insert run-time bounds checks
    \item LLVM optimizations remove always-true checks; error if always-false
\end{itemize}
\end{frame}

\begin{frame}{A Hybrid Approach}
Low* \footcite{footcite:protzenko_verified_2017}
\begin{itemize}
    \item DSL for verified, efficient low-level programming in F* (ML-like language with dependent types)
    \item Goal: write efficient \& verified C in a high-level language
    \item Write F* syntax against library modelling lower-level view of C memory
    \item Model arrays by implementation abstract buffer type using references by hyper-stacks
    \item Translate Low* to CompCert Clight
\end{itemize}
\end{frame}

%\begin{frame}{An Overview of Spatial Safety Approaches}
%Several deficiencies
%\begin{itemize}
%  \item High runtime overhead
%  \item Incomplete detection of spatial violations
%  \item Incompatible pointer representations (changing memory layout)
%  \item  Non-trivial changes to source code
%  \item Whole program analyses (for low-overhead) [e.g. Dhurjati 2006, Necula 2005]
%  \item Some of these aren't complete or sound
%  \item  Completely detecting buffer overflow (i.e. bounds) in general is undecidable!
%\end{itemize}
%\end{frame}

\section{Temporal Safety}

\begin{frame}[fragile]{Temporal Safety}
  \footnotesize
  \begin{columns}[T]
    \begin{column}{0.45\textwidth}
        Prevent accessing object that has been \emph{previously deallocated}
        \\
        Some approaches:
        \begin{itemize}
            \item Effects and regions
            \item Unique pointers and linear types
            \item Ownership and borrowing
        \end{itemize}
    \end{column}
    \begin{column}{0.45\textwidth}
\begin{lstlisting}[language=C,mathescape] %,basicstyle={\footnotesize\ttfamily}]

int TODO() {
    // fill me in
}
\end{lstlisting}
Let's list the potential problems:
        \begin{itemize}
            \item Foo
            \item Bar
            \item Baz
        \end{itemize}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{A Comment on Garbage Collection}
Garbage collection
    \begin{itemize}
        \item Relinquish control of location and layout of objects to runtime
        \item Non-zero overhead
        \item Complete temporal safety
        \item Sub-par memory use (time between unreachable and reclaimed)
        \item Used by several of the spatial approaches previously listed
        \item CCured etc. uses Boehm-Demers-Weister \footcite{boehm_garbage_1988} (free is no-op)
    \end{itemize}
\end{frame}
% \footcite{austin_efficient_1994}
% \footcite{jones_backwards-compatible_1997}
% \footcite{xu_efficient_2004}

\subsection{Effects and Regions}

\begin{frame}{Effects}
    Effect types describe the \emph{effects} of the computation leading to a value \footcite{pierce_advanced_2005}
    \\
    \todo{show simple very simple example}
    \footcite{lucassen_polymorphic_1988}
\end{frame}

\begin{frame}{Effects}
    Nielson and Nielson \footcite{nielson_type_1999} extend the simply-typed lambda calculus with annotations to demonstrate various forms of analyses:
    \begin{itemize}
        \item Control-Flow Analysis: annotate function types with function names used
        \item Binding Time Analysis: distinguish between dynamic and static data
        \item Side Effect Analysis:
            \begin{itemize}
                \item Reference variable represented by set of points where it could have been created (``region'')
                \item Annotate functions with actions they take (access, assignment, creation)
            \end{itemize}
        \item Region Inference: Compile-time determination of when to allocate regions, in which to allocate data
    \end{itemize}
\end{frame}

\begin{frame}{Effects}
    Fluent Languages \footcite{gifford_integrating_1986}
  \begin{columns}[T]
    \begin{column}{0.45\textwidth}
        \begin{itemize}
            \item Mix functional and imperative languages
            \item Every expression has a \emph{effect class}, restricting which subroutines or sublanguage features it may use
            \item Identify moeoizable (referrentially transparent) expresions via a side effect lattice
        \end{itemize}
    \end{column}

    \begin{column}{0.45\textwidth}
    \footnotesize{
    \begin{tikzpicture}
      \node (WRA) at (0,3) {$\{W\ (R)\ (A)\}$};
      \node (RA)  at (0,2) {$\{R\ (A)\}$};
      \node (A)   at (0,1) {$\{A\}$};
      \node (e)   at (0,0) {$\{\}$};
      \draw (e) -- (A) -- (RA) -- (WRA);
    \end{tikzpicture}
        \begin{itemize}
            \item (W, WR, WA, WRA) is the "Procedure" class
            \item (R, RA) is the "Observer" class
            \item (A) is the "Function" class
            \item $\{\}$ is the "Pure" class.
        \end{itemize}
    }
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Region-Based Memory Managememt}
    \footcite{tofte_region-based_1997}
    \todo{make a main slide, with graphics}
\end{frame}

\begin{frame}{Regions in C}
    \footcite{gay_language_2001}
    \footcite{grossman_region-based_2002}
    \footcite{berger_reconsidering_2002}
    \footcite{shapiro_origins_2008}
\end{frame}

\begin{frame}{Other}
    \todo {figureout how to order these}
    \footcite{deline_enforcing_2001}
    - Control-C
    \footcite{fullcite:kowshik_ensuring_2002}
    \footcite{fullcite:dhurjati_memory_2003}
   - Other
      - \footcite{strom_typestate:_1986}
      - \footcite{austin_efficient_1994}
      - \footcite{evans_static_1996}
      - \footcite{kedia_simple_2017}
    \footcite{west_cuckoo:_2005}
      \begin{itemize}
          \item restrict C for safety (not correctness)
          \item \emph{new} operator replaces malloc (space for objs reallocated for same-type objs)
          \item type system to prevent assignment of automatic obj addresses into longer-lifetime ptrs
      \end{itemize}
\end{frame}

\subsection{Unique Pointers and Linear Types}

\begin{frame}{Linear Types}
    \begin{itemize}
        \item \footcite{minsky_towards_1996}
        \item \footcite{jung_rustbelt:_2017}
        \item \footcite{matsakis_rust_2014}
        \item \footcite{girard_linear_1987}
        \item \footcite{wadler_linear_1990}
        \item \footcite{kobayashi_quasi-linear_1999}
        \item \footcite{petersen_type_2003}
        \item \footcite{ennals_linear_2004}
        \item \footcite{hawblitzel_low-level_2004}
        \item \footcite{tov_practical_2011}
        \item \footcite{amani_cogent:_2016}
        \item \footcite{oconnor_cogent:_2016}
    \end{itemize}
\end{frame}

\subsection{Ownership and Borrowing}

\begin{frame}{Ownership and Borrowing}
    \begin{itemize}
        \item \footcite{clarke_ownership_1998}
        \item \footcite{boyapati_ownership_2002}
        \item \footcite{fahndrich_language_2006}
        \item \footcite{levy_ownership_2015}
        \item \footcite{smith_alias_2000}
    \end{itemize}
\end{frame}

%\subsection{Extra Slides}
%\begin{frame}{Hardware and Other Support for Spatial Safety}
%\begin{itemize}
%    \item \footcite{arora_architectural_2006}
%    \item \footcite{devietti_hardbound:_2008}
%    \item \footcite{binary compatible, low overhead}
%      % - can reduce overhead of CCured's SEQ and WILD pointers, array bounds checking in C#
%    \item \footcite{cowan_stackguard:_1998}
%     % - inserts canaries
%    \item \footcite{hasabnis_light-weight_2012}
%     % - guard zones with good performance
%\end{itemize}
%\end{frame}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% TeX-engine: xetex
%%% End:
